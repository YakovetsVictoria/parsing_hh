{"id":"77403977","premium":false,"billing_type":{"id":"standard","name":"Стандарт"},"relations":[],"name":"Data engineer (Python Hadoop Spark)","insider_interview":null,"response_letter_required":false,"area":{"id":"1","name":"Москва","url":"https://api.hh.ru/areas/1?host=hh.ru"},"salary":null,"type":{"id":"open","name":"Открытая"},"address":null,"allow_messages":true,"experience":{"id":"between1And3","name":"От 1 года до 3 лет"},"schedule":{"id":"remote","name":"Удаленная работа"},"employment":{"id":"full","name":"Полная занятость"},"department":null,"contacts":null,"description":"<p><em><strong>X5 Group </strong>- лидер офлайн- и онлайн-рынка продуктов питания. Мы управляем портфелем брендов сетевых магазинов «Пятёрочка», «Перекрёсток», «Карусель», «Чижик», цифровыми бизнесами «Перекрёсток Впрок», «Около», 5Post, а также собственными службами логистики, прямого импорта и рядом цифровых сервисов для партнёров.</em></p> <p><em><strong>Х5 Технологии</strong> — это отдельная бизнес-единица Х5 Group, которая отвечает за создание комплексных цифровых решений для бизнес-единиц Х5.</em></p> <p><em>Наша команда — это 3000+ специалистов по информационным технологиям и большим данным. Мы разрабатываем решения, которые помогают десяткам миллионов людей.</em></p> <p><strong>«Прогнозирование спроса»</strong>: модели машинного обучения и алгоритмы, на основе данных по чекам и остаткам предупреждают сотрудников магазинов о том, что надо проверить/положить товар на полки. Продукт прошел стадию пилот (600 магазинов) и теперь дорабатывается и масштабируется на 15+ тыс. магазинов. Команда: ≈10 человек</p> <p><strong>Стек</strong>: Python 3.5-3.8., Fastapi, Hadoop, PySpark + Airflow. PostgreSQL, Kafka, Kibana, ElasticSearch. Docker, K8s, GitLab.</p> <p><strong>Основные задачи (детальнее расскажем на собеседовании)</strong>:</p> <ul> <li>Написание пайплайнов по работе с данными с использованием Airflow, Spark (пример: регулярный расчет фичей для модели, построение витрин с данными. их обновление, расчет метрик качества данных для мониторинга)</li> <li>Оптимизация расчета фичей для модели для выдерживания SLA при масштабировании продукта под большее количество магазинов</li> <li>Настройка мониторинга и алертинга качества данных и фичей с использованием Zabbix, Grafana</li> <li>Написание unit тестов (pytest), тестов для различных участков ML пайплайна, участие в код ревью</li> <li>Не обязательно, но будет большим плюсом: опыт работы с ML, выведения ML моделей в продакшн</li> </ul> <p><strong>Мы сможем рассмотреть на вакансию кандидатов, у которых есть</strong>:</p> <ul> <li>Опыт работы с Python от 2 лет</li> <li>Опыт с Hadoop, Hive, Spark</li> <li>Знание SQL (чтобы писать и оптимизировать запросы)</li> </ul> <ul> <li>Знание классических алгоритмов и структур данных</li> <li>Опыт работы с docker (kubernetes, pyspark, airflow и ds фреймворков python– не обязательно, но будет плюсом)</li> <li>Умение пользоваться git&#39;ом и работать в команде</li> </ul> <p><strong>Мы предлагаем:</strong></p> <ul> <li>Схему мотивации: Fix + бонус (20% годового оклада)</li> <li>Удобный офис в Москве или 100% удаленная работа</li> <li>Гибкий график работы</li> <li>Обратная связь, возможность профессионального и карьерного роста (2 раза в год оценка персонала)</li> <li>Возможность обучаться и сертифицироваться за счёт компании: внешние тренинги и семинары по профессиональным тематикам, отраслевые конференции, программа развития управленческих навыков, очные мастер-классы, платформы онлайн-образования и многое другое</li> <li>Яркую корпоративную жизнь с большим количеством мероприятий, конкурсов и возможностей для творческой реализации</li> <li>Широкий пакет ДМС (включая выезд за рубеж и стоматологию), страхование жизни и здоровья</li> <li>Программу привилегий Prime-zone (скидки на товары и услуги и специальные предложения от компаний-партнёров)</li> <li>Материальную помощь сотрудникам, попавшим в сложную жизненную ситуацию</li> </ul> <p>Присоединяйся к одной из самых быстрорастущих цифровых команд России!</p> <p><strong>X</strong><strong>5</strong><strong> </strong><strong>Group</strong><strong>. Создавай новый ритейл</strong></p>","branded_description":"\n\n\n<style>\n.tmpl_hh_wrapper * {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  vertical-align: baseline;\n}\n\n.hht-vacancydescription {\n  padding: 0px;\n}\n\n.tmpl_hh_wrapper .l-cell,\n.tmpl_hh_wrapper .l-paddings {\n  padding: 0px !important;\n}\n\n.tmpl_hh_wrapper .b-vacancy-desc-wrapper {\n  margin-top: 0px !important;\n}\n\n.tmpl_hh_wrapper .b-vacancy-desc {\n  overflow: visible !important;\n  line-height: inherit;\n}\n\n.tmpl_hh_content ol li b,\n.tmpl_hh_content ol li strong,\n.tmpl_hh_content ol li p b,\n.tmpl_hh_content ol li p strong,\n.tmpl_hh_content ul li b,\n.tmpl_hh_content ul li strong,\n.tmpl_hh_content ul li p b,\n.tmpl_hh_content ul li p strong {\n  font-weight: 700;\n  font-size: inherit !important;\n  color: inherit !important;\n  margin: 0 !important;\n  text-transform: none;\n   display: inline !important;\n}\n\n.tmpl_hh_content ol li p,\n.tmpl_hh_content ul li p {\n  font-weight: normal;\n  margin: 0;\n}\n\n.tmpl_hh_content p b,\n.tmpl_hh_content p strong {\n  display: inline !important;\n  margin: 0;\n  font-weight: 700;\n  font-size: inherit !important;\n}\n\n.tmpl_hh_wrapper {\n  width: 100%;\n  margin: 0 auto;\n  max-width: 43.125rem;\n  position: relative;\n  word-break: normal;\n  overflow: hidden;\n  font-family: \"Arial\", sans-serif;\n  color: #000;\n  z-index: 1;\n}\n\n.tmpl_hh_content {\n  position: relative;\n  padding: 3.125rem 1.875rem;\n  z-index: 3;\n}\n\n.tmpl_hh_content p:first-child,\n.tmpl_hh_content > strong:first-child,\n.tmpl_hh_content div > strong:first-child {\n  margin-top: 0 !important;\n}\n\n.tmpl_hh_hero {\n  background-color: #94ff43;\n  display: -ms-grid;\n  display: grid;\n  -ms-grid-columns: 1fr 21.375rem;\n  grid-template-columns: 1fr 21.375rem;\n}\n\n.tmpl_hh_hero__body {\n  padding: 2.5rem 2.8125rem 2.5rem 1.875rem;\n}\n\n.tmpl_hh_hero__logo:not(:last-child) {\n  margin-bottom: 3.75rem;\n}\n\n.tmpl_hh_hero__title {\n  font-weight: 800;\n}\n\n@supports (font-size: clamp( 1.75rem , 1.6418918919rem  +  0.5405405405vw , 1.875rem )) {\n  .tmpl_hh_hero__title {\n    font-size: clamp( 1.75rem , 1.6418918919rem  +  0.5405405405vw , 1.875rem );\n  }\n}\n\n@supports not (font-size: clamp( 1.75rem , 1.4256756757rem  +  1.6216216216vw , 2.125rem )) {\n  .tmpl_hh_hero__title {\n    font-size: calc(1.75rem + 0.375 * (100vw - 20rem) / 23.125);\n  }\n}\n\n.tmpl_hh_hero__right {\n  display: -ms-grid;\n  display: grid;\n  -ms-grid-columns: (1fr)[3];\n  grid-template-columns: repeat(3, 1fr);\n  background-color: #c3b6ff;\n}\n\n.tmpl_hh_hero__item {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n\n.tmpl_hh_company {\n  padding-left: 1.875rem;\n  font-size: 0.875rem;\n  color: #808080;\n  padding-bottom: 1.25rem;\n}\n\n.tmpl_hh_content {\n  padding: 3.125rem 1.875rem 1.25rem;\n  line-height: 1.5;\n}\n\n@supports (font-size: clamp( 0.875rem , 0.7668918919rem  +  0.5405405405vw , 1rem )) {\n  .tmpl_hh_content {\n    font-size: clamp( 0.875rem , 0.7668918919rem  +  0.5405405405vw , 1rem );\n  }\n}\n\n@supports not (font-size: clamp( 0.875rem , 0.7668918919rem  +  0.5405405405vw , 1rem )) {\n  .tmpl_hh_content {\n    font-size: calc(0.875rem + 0.125 * (100vw - 20rem) / 23.125);\n  }\n}\n\n.tmpl_hh_content p:not(:last-child):not(:last-child) {\n  margin-bottom: 1.5625rem;\n}\n\n.tmpl_hh_content strong {\n  display: block;\n  font-weight: 700;\n  line-height: 1.2;\n}\n\n@supports (font-size: clamp( 1.25rem , 1.4831081081rem  +  -0.5405405405vw , 1.375rem )) {\n  .tmpl_hh_content strong {\n    font-size: clamp( 1.25rem , 1.4831081081rem  +  -0.5405405405vw , 1.375rem );\n  }\n}\n\n@supports not (font-size: clamp( 1.25rem , 1.4831081081rem  +  -0.5405405405vw , 1.375rem )) {\n  .tmpl_hh_content strong {\n    font-size: calc(1.375rem + -0.125 * (100vw - 20rem) / 23.125);\n  }\n}\n\n@supports (margin-bottom: clamp( 0.375rem , -0.0574324324rem  +  2.1621621622vw , 0.875rem )) {\n  .tmpl_hh_content strong:not(:last-child) {\n    margin-bottom: clamp( 0.375rem , -0.0574324324rem  +  2.1621621622vw , 0.875rem );\n  }\n}\n\n@supports not (margin-bottom: clamp( 0.375rem , -0.0574324324rem  +  2.1621621622vw , 0.875rem )) {\n  .tmpl_hh_content strong:not(:last-child) {\n    margin-bottom: calc(0.375rem + 0.5 * (100vw - 20rem) / 23.125);\n  }\n}\n\n.tmpl_hh_content ul:not(:last-child) {\n  margin-bottom: 2.5rem;\n}\n\n.tmpl_hh_content li {\n  position: relative;\n}\n\n.tmpl_hh_content li:not(:last-child) {\n  margin-bottom: 0.375rem;\n}\n\n.tmpl_hh_slider {\n  position: relative;\n}\n\n.tmpl_hh_slider::before,\n.tmpl_hh_slider::after {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  border: 1px solid #000;\n}\n\n.tmpl_hh_slider::before {\n  -webkit-transform: translate(-0.5rem, 0.5rem);\n      -ms-transform: translate(-0.5rem, 0.5rem);\n          transform: translate(-0.5rem, 0.5rem);\n}\n\n.tmpl_hh_slider::after {\n  -webkit-transform: translate(-1rem, 1rem);\n      -ms-transform: translate(-1rem, 1rem);\n          transform: translate(-1rem, 1rem);\n}\n\n.tmpl_hh_slider__wrapper {\n  z-index: 2;\n}\n\n.tmpl_hh_slider__slide {\n  position: relative;\n  padding-bottom: 52.1671826625%;\n}\n\n.tmpl_hh_slider__slide img {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n\n.tmpl_hh_slider__control {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  gap: 0.75rem;\n}\n\n.tmpl_hh_slider__control:not(:last-child) {\n  margin-bottom: 1.25rem;\n}\n\n.tmpl_hh_slider__arrow {\n  cursor: pointer;\n}\n\n.tmpl_hh_slider__arrow_prev img {\n  -webkit-transform: rotate(-180deg);\n      -ms-transform: rotate(-180deg);\n          transform: rotate(-180deg);\n}\n\n.tmpl_hh_slider__arrow.swiper-button-disabled {\n  cursor: auto;\n  opacity: 0.5;\n}\n\n.tmpl_hh_footer {\n  background-color: #c3b6ff;\n  padding: 1.875rem 1.875rem 1.875rem 2.8125rem;\n}\n\n.tmpl_hh_benefits {\n  display: -ms-grid;\n  display: grid;\n  -ms-grid-columns: (1fr)[3];\n  grid-template-columns: repeat(3, 1fr);\n  gap: 2rem 0.375rem;\n}\n\n.tmpl_hh_benefits:not(:last-child) {\n  margin-bottom: 2.8125rem;\n}\n\n.tmpl_hh_benefits__item {\n  max-width: 11.25rem;\n}\n\n.tmpl_hh_benefits__icon {\n  width: 3.75rem;\n  height: 3.75rem;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  background-color: #94ff43;\n  border: 1px solid #000;\n}\n\n.tmpl_hh_benefits__icon:not(:last-child) {\n  margin-bottom: 0.625rem;\n}\n\n.tmpl_hh_benefits__text {\n  font-size: 0.75rem;\n  line-height: 1.1666666667;\n}\n\n.swiper {\n  overflow: hidden;\n}\n\n.swiper-wrapper {\n  width: 100%;\n  height: 100%;\n  -webkit-box-sizing: content-box;\n          box-sizing: content-box;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n}\n\n.swiper-vertical .swiper-wrapper {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.swiper-autoheight .swiper-wrapper {\n  -webkit-box-align: start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n}\n\n.swiper-initialized .swiper-slide {\n  -ms-flex-negative: 0;\n      flex-shrink: 0;\n}\n\n.swiper-android .swiper-slide,\n.swiper-android .swiper-wrapper {\n  -webkit-transform: translate3d(0px, 0, 0);\n          transform: translate3d(0px, 0, 0);\n}\n\n.swiper-button-lock {\n  display: none !important;\n}\n\n@media (max-width: 43.125em) {\n  .tmpl_hh_hero__logo:not(:last-child) {\n    margin-bottom: 1.25rem;\n  }\n\n  .tmpl_hh_hero {\n    -ms-grid-columns: 1fr;\n    grid-template-columns: 1fr;\n  }\n\n  .tmpl_hh_company {\n    padding-bottom: 0.625rem;\n  }\n\n  .tmpl_hh_content {\n    padding: 1.875rem 1.5625rem 1.875rem 0.3125rem;\n  }\n\n  .tmpl_hh_content p:not(:last-child):not(:last-child) {\n    margin-bottom: 0.9375rem;\n  }\n\n  .tmpl_hh_content ul:not(:last-child) {\n    margin-bottom: 1.25rem;\n  }\n\n  .tmpl_hh_content li::before {\n    margin-right: 0.375rem;\n  }\n\n  .tmpl_hh_slider::before {\n    -webkit-transform: translate(-0.25rem, 0.25rem);\n        -ms-transform: translate(-0.25rem, 0.25rem);\n            transform: translate(-0.25rem, 0.25rem);\n  }\n\n  .tmpl_hh_slider::after {\n    -webkit-transform: translate(-0.5rem, 0.5rem);\n        -ms-transform: translate(-0.5rem, 0.5rem);\n            transform: translate(-0.5rem, 0.5rem);\n  }\n\n  .tmpl_hh_footer {\n    padding: 0.9375rem 0.75rem 1.25rem;\n  }\n\n  .tmpl_hh_benefits__item:nth-child(4) {\n    -webkit-box-ordinal-group: 3;\n        -ms-flex-order: 2;\n            order: 2;\n  }\n\n  .tmpl_hh_benefits__item:nth-child(5) {\n    -webkit-box-ordinal-group: 2;\n        -ms-flex-order: 1;\n            order: 1;\n  }\n\n  .tmpl_hh_benefits__item:nth-child(6) {\n    -webkit-box-ordinal-group: 4;\n        -ms-flex-order: 3;\n            order: 3;\n  }\n\n  .tmpl_hh_benefits {\n    -ms-grid-columns: (1fr)[2];\n    grid-template-columns: repeat(2, 1fr);\n    gap: 0.9375rem 0.625rem;\n  }\n}\n\n@media (max-width: 36em) {\n  .tmpl_hh_hero__body {\n    padding: 0.9375rem 2rem 1.875rem 0.625rem !important;\n  }\n\n    .tmpl_hh_hero__title {\n        max-width: 16.25rem !important;\n    }\n\n    .tmpl_hh_hero__item:nth-child(odd) img{\nwidth: 100%;\nheight: 100%;\nobject-fit: cover;\n}\n\n@media (max-width: 63.6875em) {\n  .tmpl_hh_hero__body {\n    padding: 1rem 2rem 1rem 1.875rem;\n  }\n}\n</style>\n\n<script type=\"text/javascript\">  \n//\n(() => {\n    \"use strict\";\n    function ssr_window_esm_isObject(obj) {\n        return null !== obj && \"object\" === typeof obj && \"constructor\" in obj && obj.constructor === Object;\n    }\n    function extend(target = {}, src = {}) {\n        Object.keys(src).forEach((key => {\n            if (\"undefined\" === typeof target[key]) target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);\n        }));\n    }\n    const ssrDocument = {\n        body: {},\n        addEventListener() {},\n        removeEventListener() {},\n        activeElement: {\n            blur() {},\n            nodeName: \"\"\n        },\n        querySelector() {\n            return null;\n        },\n        querySelectorAll() {\n            return [];\n        },\n        getElementById() {\n            return null;\n        },\n        createEvent() {\n            return {\n                initEvent() {}\n            };\n        },\n        createElement() {\n            return {\n                children: [],\n                childNodes: [],\n                style: {},\n                setAttribute() {},\n                getElementsByTagName() {\n                    return [];\n                }\n            };\n        },\n        createElementNS() {\n            return {};\n        },\n        importNode() {\n            return null;\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        }\n    };\n    function ssr_window_esm_getDocument() {\n        const doc = \"undefined\" !== typeof document ? document : {};\n        extend(doc, ssrDocument);\n        return doc;\n    }\n    const ssrWindow = {\n        document: ssrDocument,\n        navigator: {\n            userAgent: \"\"\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        },\n        history: {\n            replaceState() {},\n            pushState() {},\n            go() {},\n            back() {}\n        },\n        CustomEvent: function CustomEvent() {\n            return this;\n        },\n        addEventListener() {},\n        removeEventListener() {},\n        getComputedStyle() {\n            return {\n                getPropertyValue() {\n                    return \"\";\n                }\n            };\n        },\n        Image() {},\n        Date() {},\n        screen: {},\n        setTimeout() {},\n        clearTimeout() {},\n        matchMedia() {\n            return {};\n        },\n        requestAnimationFrame(callback) {\n            if (\"undefined\" === typeof setTimeout) {\n                callback();\n                return null;\n            }\n            return setTimeout(callback, 0);\n        },\n        cancelAnimationFrame(id) {\n            if (\"undefined\" === typeof setTimeout) return;\n            clearTimeout(id);\n        }\n    };\n    function ssr_window_esm_getWindow() {\n        const win = \"undefined\" !== typeof window ? window : {};\n        extend(win, ssrWindow);\n        return win;\n    }\n    function makeReactive(obj) {\n        const proto = obj.__proto__;\n        Object.defineProperty(obj, \"__proto__\", {\n            get() {\n                return proto;\n            },\n            set(value) {\n                proto.__proto__ = value;\n            }\n        });\n    }\n    class Dom7 extends Array {\n        constructor(items) {\n            if (\"number\" === typeof items) super(items); else {\n                super(...items || []);\n                makeReactive(this);\n            }\n        }\n    }\n    function arrayFlat(arr = []) {\n        const res = [];\n        arr.forEach((el => {\n            if (Array.isArray(el)) res.push(...arrayFlat(el)); else res.push(el);\n        }));\n        return res;\n    }\n    function arrayFilter(arr, callback) {\n        return Array.prototype.filter.call(arr, callback);\n    }\n    function arrayUnique(arr) {\n        const uniqueArray = [];\n        for (let i = 0; i < arr.length; i += 1) if (-1 === uniqueArray.indexOf(arr[i])) uniqueArray.push(arr[i]);\n        return uniqueArray;\n    }\n    function qsa(selector, context) {\n        if (\"string\" !== typeof selector) return [ selector ];\n        const a = [];\n        const res = context.querySelectorAll(selector);\n        for (let i = 0; i < res.length; i += 1) a.push(res[i]);\n        return a;\n    }\n    function dom7_esm_$(selector, context) {\n        const window = ssr_window_esm_getWindow();\n        const document = ssr_window_esm_getDocument();\n        let arr = [];\n        if (!context && selector instanceof Dom7) return selector;\n        if (!selector) return new Dom7(arr);\n        if (\"string\" === typeof selector) {\n            const html = selector.trim();\n            if (html.indexOf(\"<\") >= 0 && html.indexOf(\">\") >= 0) {\n                let toCreate = \"div\";\n                if (0 === html.indexOf(\"<li\")) toCreate = \"ul\";\n                if (0 === html.indexOf(\"<tr\")) toCreate = \"tbody\";\n                if (0 === html.indexOf(\"<td\") || 0 === html.indexOf(\"<th\")) toCreate = \"tr\";\n                if (0 === html.indexOf(\"<tbody\")) toCreate = \"table\";\n                if (0 === html.indexOf(\"<option\")) toCreate = \"select\";\n                const tempParent = document.createElement(toCreate);\n                tempParent.innerHTML = html;\n                for (let i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i]);\n            } else arr = qsa(selector.trim(), context || document);\n        } else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (Array.isArray(selector)) {\n            if (selector instanceof Dom7) return selector;\n            arr = selector;\n        }\n        return new Dom7(arrayUnique(arr));\n    }\n    dom7_esm_$.fn = Dom7.prototype;\n    function addClass(...classes) {\n        const classNames = arrayFlat(classes.map((c => c.split(\" \"))));\n        this.forEach((el => {\n            el.classList.add(...classNames);\n        }));\n        return this;\n    }\n    function removeClass(...classes) {\n        const classNames = arrayFlat(classes.map((c => c.split(\" \"))));\n        this.forEach((el => {\n            el.classList.remove(...classNames);\n        }));\n        return this;\n    }\n    function toggleClass(...classes) {\n        const classNames = arrayFlat(classes.map((c => c.split(\" \"))));\n        this.forEach((el => {\n            classNames.forEach((className => {\n                el.classList.toggle(className);\n            }));\n        }));\n    }\n    function hasClass(...classes) {\n        const classNames = arrayFlat(classes.map((c => c.split(\" \"))));\n        return arrayFilter(this, (el => classNames.filter((className => el.classList.contains(className))).length > 0)).length > 0;\n    }\n    function attr(attrs, value) {\n        if (1 === arguments.length && \"string\" === typeof attrs) {\n            if (this[0]) return this[0].getAttribute(attrs);\n            return;\n        }\n        for (let i = 0; i < this.length; i += 1) if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (const attrName in attrs) {\n            this[i][attrName] = attrs[attrName];\n            this[i].setAttribute(attrName, attrs[attrName]);\n        }\n        return this;\n    }\n    function removeAttr(attr) {\n        for (let i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);\n        return this;\n    }\n    function transform(transform) {\n        for (let i = 0; i < this.length; i += 1) this[i].style.transform = transform;\n        return this;\n    }\n    function transition(duration) {\n        for (let i = 0; i < this.length; i += 1) this[i].style.transitionDuration = \"string\" !== typeof duration ? `${duration}ms` : duration;\n        return this;\n    }\n    function on(...args) {\n        let [eventType, targetSelector, listener, capture] = args;\n        if (\"function\" === typeof args[1]) {\n            [eventType, listener, capture] = args;\n            targetSelector = void 0;\n        }\n        if (!capture) capture = false;\n        function handleLiveEvent(e) {\n            const target = e.target;\n            if (!target) return;\n            const eventData = e.target.dom7EventData || [];\n            if (eventData.indexOf(e) < 0) eventData.unshift(e);\n            if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData); else {\n                const parents = dom7_esm_$(target).parents();\n                for (let k = 0; k < parents.length; k += 1) if (dom7_esm_$(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n            }\n        }\n        function handleEvent(e) {\n            const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n            if (eventData.indexOf(e) < 0) eventData.unshift(e);\n            listener.apply(this, eventData);\n        }\n        const events = eventType.split(\" \");\n        let j;\n        for (let i = 0; i < this.length; i += 1) {\n            const el = this[i];\n            if (!targetSelector) for (j = 0; j < events.length; j += 1) {\n                const event = events[j];\n                if (!el.dom7Listeners) el.dom7Listeners = {};\n                if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n                el.dom7Listeners[event].push({\n                    listener,\n                    proxyListener: handleEvent\n                });\n                el.addEventListener(event, handleEvent, capture);\n            } else for (j = 0; j < events.length; j += 1) {\n                const event = events[j];\n                if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n                if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n                el.dom7LiveListeners[event].push({\n                    listener,\n                    proxyListener: handleLiveEvent\n                });\n                el.addEventListener(event, handleLiveEvent, capture);\n            }\n        }\n        return this;\n    }\n    function off(...args) {\n        let [eventType, targetSelector, listener, capture] = args;\n        if (\"function\" === typeof args[1]) {\n            [eventType, listener, capture] = args;\n            targetSelector = void 0;\n        }\n        if (!capture) capture = false;\n        const events = eventType.split(\" \");\n        for (let i = 0; i < events.length; i += 1) {\n            const event = events[i];\n            for (let j = 0; j < this.length; j += 1) {\n                const el = this[j];\n                let handlers;\n                if (!targetSelector && el.dom7Listeners) handlers = el.dom7Listeners[event]; else if (targetSelector && el.dom7LiveListeners) handlers = el.dom7LiveListeners[event];\n                if (handlers && handlers.length) for (let k = handlers.length - 1; k >= 0; k -= 1) {\n                    const handler = handlers[k];\n                    if (listener && handler.listener === listener) {\n                        el.removeEventListener(event, handler.proxyListener, capture);\n                        handlers.splice(k, 1);\n                    } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n                        el.removeEventListener(event, handler.proxyListener, capture);\n                        handlers.splice(k, 1);\n                    } else if (!listener) {\n                        el.removeEventListener(event, handler.proxyListener, capture);\n                        handlers.splice(k, 1);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    function trigger(...args) {\n        const window = ssr_window_esm_getWindow();\n        const events = args[0].split(\" \");\n        const eventData = args[1];\n        for (let i = 0; i < events.length; i += 1) {\n            const event = events[i];\n            for (let j = 0; j < this.length; j += 1) {\n                const el = this[j];\n                if (window.CustomEvent) {\n                    const evt = new window.CustomEvent(event, {\n                        detail: eventData,\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    el.dom7EventData = args.filter(((data, dataIndex) => dataIndex > 0));\n                    el.dispatchEvent(evt);\n                    el.dom7EventData = [];\n                    delete el.dom7EventData;\n                }\n            }\n        }\n        return this;\n    }\n    function transitionEnd(callback) {\n        const dom = this;\n        function fireCallBack(e) {\n            if (e.target !== this) return;\n            callback.call(this, e);\n            dom.off(\"transitionend\", fireCallBack);\n        }\n        if (callback) dom.on(\"transitionend\", fireCallBack);\n        return this;\n    }\n    function dom7_esm_outerWidth(includeMargins) {\n        if (this.length > 0) {\n            if (includeMargins) {\n                const styles = this.styles();\n                return this[0].offsetWidth + parseFloat(styles.getPropertyValue(\"margin-right\")) + parseFloat(styles.getPropertyValue(\"margin-left\"));\n            }\n            return this[0].offsetWidth;\n        }\n        return null;\n    }\n    function dom7_esm_outerHeight(includeMargins) {\n        if (this.length > 0) {\n            if (includeMargins) {\n                const styles = this.styles();\n                return this[0].offsetHeight + parseFloat(styles.getPropertyValue(\"margin-top\")) + parseFloat(styles.getPropertyValue(\"margin-bottom\"));\n            }\n            return this[0].offsetHeight;\n        }\n        return null;\n    }\n    function offset() {\n        if (this.length > 0) {\n            const window = ssr_window_esm_getWindow();\n            const document = ssr_window_esm_getDocument();\n            const el = this[0];\n            const box = el.getBoundingClientRect();\n            const body = document.body;\n            const clientTop = el.clientTop || body.clientTop || 0;\n            const clientLeft = el.clientLeft || body.clientLeft || 0;\n            const scrollTop = el === window ? window.scrollY : el.scrollTop;\n            const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n            return {\n                top: box.top + scrollTop - clientTop,\n                left: box.left + scrollLeft - clientLeft\n            };\n        }\n        return null;\n    }\n    function styles() {\n        const window = ssr_window_esm_getWindow();\n        if (this[0]) return window.getComputedStyle(this[0], null);\n        return {};\n    }\n    function css(props, value) {\n        const window = ssr_window_esm_getWindow();\n        let i;\n        if (1 === arguments.length) if (\"string\" === typeof props) {\n            if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n        } else {\n            for (i = 0; i < this.length; i += 1) for (const prop in props) this[i].style[prop] = props[prop];\n            return this;\n        }\n        if (2 === arguments.length && \"string\" === typeof props) {\n            for (i = 0; i < this.length; i += 1) this[i].style[props] = value;\n            return this;\n        }\n        return this;\n    }\n    function each(callback) {\n        if (!callback) return this;\n        this.forEach(((el, index) => {\n            callback.apply(el, [ el, index ]);\n        }));\n        return this;\n    }\n    function filter(callback) {\n        const result = arrayFilter(this, callback);\n        return dom7_esm_$(result);\n    }\n    function html(html) {\n        if (\"undefined\" === typeof html) return this[0] ? this[0].innerHTML : null;\n        for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;\n        return this;\n    }\n    function dom7_esm_text(text) {\n        if (\"undefined\" === typeof text) return this[0] ? this[0].textContent.trim() : null;\n        for (let i = 0; i < this.length; i += 1) this[i].textContent = text;\n        return this;\n    }\n    function is(selector) {\n        const window = ssr_window_esm_getWindow();\n        const document = ssr_window_esm_getDocument();\n        const el = this[0];\n        let compareWith;\n        let i;\n        if (!el || \"undefined\" === typeof selector) return false;\n        if (\"string\" === typeof selector) {\n            if (el.matches) return el.matches(selector);\n            if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n            if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n            compareWith = dom7_esm_$(selector);\n            for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;\n            return false;\n        }\n        if (selector === document) return el === document;\n        if (selector === window) return el === window;\n        if (selector.nodeType || selector instanceof Dom7) {\n            compareWith = selector.nodeType ? [ selector ] : selector;\n            for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;\n            return false;\n        }\n        return false;\n    }\n    function index() {\n        let child = this[0];\n        let i;\n        if (child) {\n            i = 0;\n            while (null !== (child = child.previousSibling)) if (1 === child.nodeType) i += 1;\n            return i;\n        }\n        return;\n    }\n    function eq(index) {\n        if (\"undefined\" === typeof index) return this;\n        const length = this.length;\n        if (index > length - 1) return dom7_esm_$([]);\n        if (index < 0) {\n            const returnIndex = length + index;\n            if (returnIndex < 0) return dom7_esm_$([]);\n            return dom7_esm_$([ this[returnIndex] ]);\n        }\n        return dom7_esm_$([ this[index] ]);\n    }\n    function append(...els) {\n        let newChild;\n        const document = ssr_window_esm_getDocument();\n        for (let k = 0; k < els.length; k += 1) {\n            newChild = els[k];\n            for (let i = 0; i < this.length; i += 1) if (\"string\" === typeof newChild) {\n                const tempDiv = document.createElement(\"div\");\n                tempDiv.innerHTML = newChild;\n                while (tempDiv.firstChild) this[i].appendChild(tempDiv.firstChild);\n            } else if (newChild instanceof Dom7) for (let j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);\n        }\n        return this;\n    }\n    function prepend(newChild) {\n        const document = ssr_window_esm_getDocument();\n        let i;\n        let j;\n        for (i = 0; i < this.length; i += 1) if (\"string\" === typeof newChild) {\n            const tempDiv = document.createElement(\"div\");\n            tempDiv.innerHTML = newChild;\n            for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n        } else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);\n        return this;\n    }\n    function next(selector) {\n        if (this.length > 0) {\n            if (selector) {\n                if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) return dom7_esm_$([ this[0].nextElementSibling ]);\n                return dom7_esm_$([]);\n            }\n            if (this[0].nextElementSibling) return dom7_esm_$([ this[0].nextElementSibling ]);\n            return dom7_esm_$([]);\n        }\n        return dom7_esm_$([]);\n    }\n    function nextAll(selector) {\n        const nextEls = [];\n        let el = this[0];\n        if (!el) return dom7_esm_$([]);\n        while (el.nextElementSibling) {\n            const next = el.nextElementSibling;\n            if (selector) {\n                if (dom7_esm_$(next).is(selector)) nextEls.push(next);\n            } else nextEls.push(next);\n            el = next;\n        }\n        return dom7_esm_$(nextEls);\n    }\n    function prev(selector) {\n        if (this.length > 0) {\n            const el = this[0];\n            if (selector) {\n                if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) return dom7_esm_$([ el.previousElementSibling ]);\n                return dom7_esm_$([]);\n            }\n            if (el.previousElementSibling) return dom7_esm_$([ el.previousElementSibling ]);\n            return dom7_esm_$([]);\n        }\n        return dom7_esm_$([]);\n    }\n    function prevAll(selector) {\n        const prevEls = [];\n        let el = this[0];\n        if (!el) return dom7_esm_$([]);\n        while (el.previousElementSibling) {\n            const prev = el.previousElementSibling;\n            if (selector) {\n                if (dom7_esm_$(prev).is(selector)) prevEls.push(prev);\n            } else prevEls.push(prev);\n            el = prev;\n        }\n        return dom7_esm_$(prevEls);\n    }\n    function dom7_esm_parent(selector) {\n        const parents = [];\n        for (let i = 0; i < this.length; i += 1) if (null !== this[i].parentNode) if (selector) {\n            if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n        } else parents.push(this[i].parentNode);\n        return dom7_esm_$(parents);\n    }\n    function parents(selector) {\n        const parents = [];\n        for (let i = 0; i < this.length; i += 1) {\n            let parent = this[i].parentNode;\n            while (parent) {\n                if (selector) {\n                    if (dom7_esm_$(parent).is(selector)) parents.push(parent);\n                } else parents.push(parent);\n                parent = parent.parentNode;\n            }\n        }\n        return dom7_esm_$(parents);\n    }\n    function closest(selector) {\n        let closest = this;\n        if (\"undefined\" === typeof selector) return dom7_esm_$([]);\n        if (!closest.is(selector)) closest = closest.parents(selector).eq(0);\n        return closest;\n    }\n    function find(selector) {\n        const foundElements = [];\n        for (let i = 0; i < this.length; i += 1) {\n            const found = this[i].querySelectorAll(selector);\n            for (let j = 0; j < found.length; j += 1) foundElements.push(found[j]);\n        }\n        return dom7_esm_$(foundElements);\n    }\n    function children(selector) {\n        const children = [];\n        for (let i = 0; i < this.length; i += 1) {\n            const childNodes = this[i].children;\n            for (let j = 0; j < childNodes.length; j += 1) if (!selector || dom7_esm_$(childNodes[j]).is(selector)) children.push(childNodes[j]);\n        }\n        return dom7_esm_$(children);\n    }\n    function remove() {\n        for (let i = 0; i < this.length; i += 1) if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n        return this;\n    }\n    const noTrigger = \"resize scroll\".split(\" \");\n    function shortcut(name) {\n        function eventHandler(...args) {\n            if (\"undefined\" === typeof args[0]) {\n                for (let i = 0; i < this.length; i += 1) if (noTrigger.indexOf(name) < 0) if (name in this[i]) this[i][name](); else dom7_esm_$(this[i]).trigger(name);\n                return this;\n            }\n            return this.on(name, ...args);\n        }\n        return eventHandler;\n    }\n    shortcut(\"click\");\n    shortcut(\"blur\");\n    shortcut(\"focus\");\n    shortcut(\"focusin\");\n    shortcut(\"focusout\");\n    shortcut(\"keyup\");\n    shortcut(\"keydown\");\n    shortcut(\"keypress\");\n    shortcut(\"submit\");\n    shortcut(\"change\");\n    shortcut(\"mousedown\");\n    shortcut(\"mousemove\");\n    shortcut(\"mouseup\");\n    shortcut(\"mouseenter\");\n    shortcut(\"mouseleave\");\n    shortcut(\"mouseout\");\n    shortcut(\"mouseover\");\n    shortcut(\"touchstart\");\n    shortcut(\"touchend\");\n    shortcut(\"touchmove\");\n    shortcut(\"resize\");\n    shortcut(\"scroll\");\n    const Methods = {\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        attr,\n        removeAttr,\n        transform,\n        transition,\n        on,\n        off,\n        trigger,\n        transitionEnd,\n        outerWidth: dom7_esm_outerWidth,\n        outerHeight: dom7_esm_outerHeight,\n        styles,\n        offset,\n        css,\n        each,\n        html,\n        text: dom7_esm_text,\n        is,\n        index,\n        eq,\n        append,\n        prepend,\n        next,\n        nextAll,\n        prev,\n        prevAll,\n        parent: dom7_esm_parent,\n        parents,\n        closest,\n        find,\n        children,\n        filter,\n        remove\n    };\n    Object.keys(Methods).forEach((methodName => {\n        Object.defineProperty(dom7_esm_$.fn, methodName, {\n            value: Methods[methodName],\n            writable: true\n        });\n    }));\n    const dom = dom7_esm_$;\n    function deleteProps(obj) {\n        const object = obj;\n        Object.keys(object).forEach((key => {\n            try {\n                object[key] = null;\n            } catch (e) {}\n            try {\n                delete object[key];\n            } catch (e) {}\n        }));\n    }\n    function utils_nextTick(callback, delay) {\n        if (void 0 === delay) delay = 0;\n        return setTimeout(callback, delay);\n    }\n    function utils_now() {\n        return Date.now();\n    }\n    function utils_getComputedStyle(el) {\n        const window = ssr_window_esm_getWindow();\n        let style;\n        if (window.getComputedStyle) style = window.getComputedStyle(el, null);\n        if (!style && el.currentStyle) style = el.currentStyle;\n        if (!style) style = el.style;\n        return style;\n    }\n    function utils_getTranslate(el, axis) {\n        if (void 0 === axis) axis = \"x\";\n        const window = ssr_window_esm_getWindow();\n        let matrix;\n        let curTransform;\n        let transformMatrix;\n        const curStyle = utils_getComputedStyle(el, null);\n        if (window.WebKitCSSMatrix) {\n            curTransform = curStyle.transform || curStyle.webkitTransform;\n            if (curTransform.split(\",\").length > 6) curTransform = curTransform.split(\", \").map((a => a.replace(\",\", \".\"))).join(\", \");\n            transformMatrix = new window.WebKitCSSMatrix(\"none\" === curTransform ? \"\" : curTransform);\n        } else {\n            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n            matrix = transformMatrix.toString().split(\",\");\n        }\n        if (\"x\" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (16 === matrix.length) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);\n        if (\"y\" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (16 === matrix.length) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);\n        return curTransform || 0;\n    }\n    function utils_isObject(o) {\n        return \"object\" === typeof o && null !== o && o.constructor && \"Object\" === Object.prototype.toString.call(o).slice(8, -1);\n    }\n    function isNode(node) {\n        if (\"undefined\" !== typeof window && \"undefined\" !== typeof window.HTMLElement) return node instanceof HTMLElement;\n        return node && (1 === node.nodeType || 11 === node.nodeType);\n    }\n    function utils_extend() {\n        const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);\n        const noExtend = [ \"__proto__\", \"constructor\", \"prototype\" ];\n        for (let i = 1; i < arguments.length; i += 1) {\n            const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];\n            if (void 0 !== nextSource && null !== nextSource && !isNode(nextSource)) {\n                const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));\n                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n                    const nextKey = keysArray[nextIndex];\n                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (void 0 !== desc && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {\n                        to[nextKey] = {};\n                        if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);\n                    } else to[nextKey] = nextSource[nextKey];\n                }\n            }\n        }\n        return to;\n    }\n    function utils_setCSSProperty(el, varName, varValue) {\n        el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n        let {swiper, targetPosition, side} = _ref;\n        const window = ssr_window_esm_getWindow();\n        const startPosition = -swiper.translate;\n        let startTime = null;\n        let time;\n        const duration = swiper.params.speed;\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\n        const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n        const isOutOfBound = (current, target) => \"next\" === dir && current >= target || \"prev\" === dir && current <= target;\n        const animate = () => {\n            time = (new Date).getTime();\n            if (null === startTime) startTime = time;\n            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n            const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;\n            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n            if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;\n            swiper.wrapperEl.scrollTo({\n                [side]: currentPosition\n            });\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.scrollSnapType = \"\";\n                setTimeout((() => {\n                    swiper.wrapperEl.style.overflow = \"\";\n                    swiper.wrapperEl.scrollTo({\n                        [side]: currentPosition\n                    });\n                }));\n                window.cancelAnimationFrame(swiper.cssModeFrameID);\n                return;\n            }\n            swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    let support;\n    function calcSupport() {\n        const window = ssr_window_esm_getWindow();\n        const document = ssr_window_esm_getDocument();\n        return {\n            smoothScroll: document.documentElement && \"scrollBehavior\" in document.documentElement.style,\n            touch: !!(\"ontouchstart\" in window || window.DocumentTouch && document instanceof window.DocumentTouch),\n            passiveListener: function checkPassiveListener() {\n                let supportsPassive = false;\n                try {\n                    const opts = Object.defineProperty({}, \"passive\", {\n                        get() {\n                            supportsPassive = true;\n                        }\n                    });\n                    window.addEventListener(\"testPassiveListener\", null, opts);\n                } catch (e) {}\n                return supportsPassive;\n            }(),\n            gestures: function checkGestures() {\n                return \"ongesturestart\" in window;\n            }()\n        };\n    }\n    function getSupport() {\n        if (!support) support = calcSupport();\n        return support;\n    }\n    let deviceCached;\n    function calcDevice(_temp) {\n        let {userAgent} = void 0 === _temp ? {} : _temp;\n        const support = getSupport();\n        const window = ssr_window_esm_getWindow();\n        const platform = window.navigator.platform;\n        const ua = userAgent || window.navigator.userAgent;\n        const device = {\n            ios: false,\n            android: false\n        };\n        const screenWidth = window.screen.width;\n        const screenHeight = window.screen.height;\n        const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n        const windows = \"Win32\" === platform;\n        let macos = \"MacIntel\" === platform;\n        const iPadScreens = [ \"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\" ];\n        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n            ipad = ua.match(/(Version)\\/([\\d.]+)/);\n            if (!ipad) ipad = [ 0, 1, \"13_0_0\" ];\n            macos = false;\n        }\n        if (android && !windows) {\n            device.os = \"android\";\n            device.android = true;\n        }\n        if (ipad || iphone || ipod) {\n            device.os = \"ios\";\n            device.ios = true;\n        }\n        return device;\n    }\n    function getDevice(overrides) {\n        if (void 0 === overrides) overrides = {};\n        if (!deviceCached) deviceCached = calcDevice(overrides);\n        return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n        const window = ssr_window_esm_getWindow();\n        function isSafari() {\n            const ua = window.navigator.userAgent.toLowerCase();\n            return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n        }\n        return {\n            isSafari: isSafari(),\n            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n        };\n    }\n    function getBrowser() {\n        if (!browser) browser = calcBrowser();\n        return browser;\n    }\n    function Resize(_ref) {\n        let {swiper, on, emit} = _ref;\n        const window = ssr_window_esm_getWindow();\n        let observer = null;\n        let animationFrame = null;\n        const resizeHandler = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"beforeResize\");\n            emit(\"resize\");\n        };\n        const createObserver = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            observer = new ResizeObserver((entries => {\n                animationFrame = window.requestAnimationFrame((() => {\n                    const {width, height} = swiper;\n                    let newWidth = width;\n                    let newHeight = height;\n                    entries.forEach((_ref2 => {\n                        let {contentBoxSize, contentRect, target} = _ref2;\n                        if (target && target !== swiper.el) return;\n                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                    }));\n                    if (newWidth !== width || newHeight !== height) resizeHandler();\n                }));\n            }));\n            observer.observe(swiper.el);\n        };\n        const removeObserver = () => {\n            if (animationFrame) window.cancelAnimationFrame(animationFrame);\n            if (observer && observer.unobserve && swiper.el) {\n                observer.unobserve(swiper.el);\n                observer = null;\n            }\n        };\n        const orientationChangeHandler = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"orientationchange\");\n        };\n        on(\"init\", (() => {\n            if (swiper.params.resizeObserver && \"undefined\" !== typeof window.ResizeObserver) {\n                createObserver();\n                return;\n            }\n            window.addEventListener(\"resize\", resizeHandler);\n            window.addEventListener(\"orientationchange\", orientationChangeHandler);\n        }));\n        on(\"destroy\", (() => {\n            removeObserver();\n            window.removeEventListener(\"resize\", resizeHandler);\n            window.removeEventListener(\"orientationchange\", orientationChangeHandler);\n        }));\n    }\n    function Observer(_ref) {\n        let {swiper, extendParams, on, emit} = _ref;\n        const observers = [];\n        const window = ssr_window_esm_getWindow();\n        const attach = function(target, options) {\n            if (void 0 === options) options = {};\n            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n            const observer = new ObserverFunc((mutations => {\n                if (1 === mutations.length) {\n                    emit(\"observerUpdate\", mutations[0]);\n                    return;\n                }\n                const observerUpdate = function observerUpdate() {\n                    emit(\"observerUpdate\", mutations[0]);\n                };\n                if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);\n            }));\n            observer.observe(target, {\n                attributes: \"undefined\" === typeof options.attributes ? true : options.attributes,\n                childList: \"undefined\" === typeof options.childList ? true : options.childList,\n                characterData: \"undefined\" === typeof options.characterData ? true : options.characterData\n            });\n            observers.push(observer);\n        };\n        const init = () => {\n            if (!swiper.params.observer) return;\n            if (swiper.params.observeParents) {\n                const containerParents = swiper.$el.parents();\n                for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);\n            }\n            attach(swiper.$el[0], {\n                childList: swiper.params.observeSlideChildren\n            });\n            attach(swiper.$wrapperEl[0], {\n                attributes: false\n            });\n        };\n        const destroy = () => {\n            observers.forEach((observer => {\n                observer.disconnect();\n            }));\n            observers.splice(0, observers.length);\n        };\n        extendParams({\n            observer: false,\n            observeParents: false,\n            observeSlideChildren: false\n        });\n        on(\"init\", init);\n        on(\"destroy\", destroy);\n    }\n    const events_emitter = {\n        on(events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (\"function\" !== typeof handler) return self;\n            const method = priority ? \"unshift\" : \"push\";\n            events.split(\" \").forEach((event => {\n                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n                self.eventsListeners[event][method](handler);\n            }));\n            return self;\n        },\n        once(events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (\"function\" !== typeof handler) return self;\n            function onceHandler() {\n                self.off(events, onceHandler);\n                if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n                handler.apply(self, args);\n            }\n            onceHandler.__emitterProxy = handler;\n            return self.on(events, onceHandler, priority);\n        },\n        onAny(handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (\"function\" !== typeof handler) return self;\n            const method = priority ? \"unshift\" : \"push\";\n            if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);\n            return self;\n        },\n        offAny(handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsAnyListeners) return self;\n            const index = self.eventsAnyListeners.indexOf(handler);\n            if (index >= 0) self.eventsAnyListeners.splice(index, 1);\n            return self;\n        },\n        off(events, handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            events.split(\" \").forEach((event => {\n                if (\"undefined\" === typeof handler) self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);\n                }));\n            }));\n            return self;\n        },\n        emit() {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            let events;\n            let data;\n            let context;\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n            if (\"string\" === typeof args[0] || Array.isArray(args[0])) {\n                events = args[0];\n                data = args.slice(1, args.length);\n                context = self;\n            } else {\n                events = args[0].events;\n                data = args[0].data;\n                context = args[0].context || self;\n            }\n            data.unshift(context);\n            const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n            eventsArray.forEach((event => {\n                if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {\n                    eventHandler.apply(context, [ event, ...data ]);\n                }));\n                if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {\n                    eventHandler.apply(context, data);\n                }));\n            }));\n            return self;\n        }\n    };\n    function updateSize() {\n        const swiper = this;\n        let width;\n        let height;\n        const $el = swiper.$el;\n        if (\"undefined\" !== typeof swiper.params.width && null !== swiper.params.width) width = swiper.params.width; else width = $el[0].clientWidth;\n        if (\"undefined\" !== typeof swiper.params.height && null !== swiper.params.height) height = swiper.params.height; else height = $el[0].clientHeight;\n        if (0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical()) return;\n        width = width - parseInt($el.css(\"padding-left\") || 0, 10) - parseInt($el.css(\"padding-right\") || 0, 10);\n        height = height - parseInt($el.css(\"padding-top\") || 0, 10) - parseInt($el.css(\"padding-bottom\") || 0, 10);\n        if (Number.isNaN(width)) width = 0;\n        if (Number.isNaN(height)) height = 0;\n        Object.assign(swiper, {\n            width,\n            height,\n            size: swiper.isHorizontal() ? width : height\n        });\n    }\n    function updateSlides() {\n        const swiper = this;\n        function getDirectionLabel(property) {\n            if (swiper.isHorizontal()) return property;\n            return {\n                width: \"height\",\n                \"margin-top\": \"margin-left\",\n                \"margin-bottom \": \"margin-right\",\n                \"margin-left\": \"margin-top\",\n                \"margin-right\": \"margin-bottom\",\n                \"padding-left\": \"padding-top\",\n                \"padding-right\": \"padding-bottom\",\n                marginRight: \"marginBottom\"\n            }[property];\n        }\n        function getDirectionPropertyValue(node, label) {\n            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n        }\n        const params = swiper.params;\n        const {$wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n        const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n        let snapGrid = [];\n        const slidesGrid = [];\n        const slidesSizesGrid = [];\n        let offsetBefore = params.slidesOffsetBefore;\n        if (\"function\" === typeof offsetBefore) offsetBefore = params.slidesOffsetBefore.call(swiper);\n        let offsetAfter = params.slidesOffsetAfter;\n        if (\"function\" === typeof offsetAfter) offsetAfter = params.slidesOffsetAfter.call(swiper);\n        const previousSnapGridLength = swiper.snapGrid.length;\n        const previousSlidesGridLength = swiper.slidesGrid.length;\n        let spaceBetween = params.spaceBetween;\n        let slidePosition = -offsetBefore;\n        let prevSlideSize = 0;\n        let index = 0;\n        if (\"undefined\" === typeof swiperSize) return;\n        if (\"string\" === typeof spaceBetween && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n        swiper.virtualSize = -spaceBetween;\n        if (rtl) slides.css({\n            marginLeft: \"\",\n            marginBottom: \"\",\n            marginTop: \"\"\n        }); else slides.css({\n            marginRight: \"\",\n            marginBottom: \"\",\n            marginTop: \"\"\n        });\n        if (params.centeredSlides && params.cssMode) {\n            utils_setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-before\", \"\");\n            utils_setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-after\", \"\");\n        }\n        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n        if (gridEnabled) swiper.grid.initSlides(slidesLength);\n        let slideSize;\n        const shouldResetSlideSize = \"auto\" === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter((key => \"undefined\" !== typeof params.breakpoints[key].slidesPerView)).length > 0;\n        for (let i = 0; i < slidesLength; i += 1) {\n            slideSize = 0;\n            const slide = slides.eq(i);\n            if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n            if (\"none\" === slide.css(\"display\")) continue;\n            if (\"auto\" === params.slidesPerView) {\n                if (shouldResetSlideSize) slides[i].style[getDirectionLabel(\"width\")] = ``;\n                const slideStyles = getComputedStyle(slide[0]);\n                const currentTransform = slide[0].style.transform;\n                const currentWebKitTransform = slide[0].style.webkitTransform;\n                if (currentTransform) slide[0].style.transform = \"none\";\n                if (currentWebKitTransform) slide[0].style.webkitTransform = \"none\";\n                if (params.roundLengths) slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true); else {\n                    const width = getDirectionPropertyValue(slideStyles, \"width\");\n                    const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                    const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                    const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                    const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                    const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                    if (boxSizing && \"border-box\" === boxSizing) slideSize = width + marginLeft + marginRight; else {\n                        const {clientWidth, offsetWidth} = slide[0];\n                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                    }\n                }\n                if (currentTransform) slide[0].style.transform = currentTransform;\n                if (currentWebKitTransform) slide[0].style.webkitTransform = currentWebKitTransform;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n            } else {\n                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n                if (slides[i]) slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n            if (slides[i]) slides[i].swiperSlideSize = slideSize;\n            slidesSizesGrid.push(slideSize);\n            if (params.centeredSlides) {\n                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n                if (0 === prevSlideSize && 0 !== i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (0 === i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n            } else {\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n                slidePosition = slidePosition + slideSize + spaceBetween;\n            }\n            swiper.virtualSize += slideSize + spaceBetween;\n            prevSlideSize = slideSize;\n            index += 1;\n        }\n        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n        if (rtl && wrongRTL && (\"slide\" === params.effect || \"coverflow\" === params.effect)) $wrapperEl.css({\n            width: `${swiper.virtualSize + params.spaceBetween}px`\n        });\n        if (params.setWrapperSize) $wrapperEl.css({\n            [getDirectionLabel(\"width\")]: `${swiper.virtualSize + params.spaceBetween}px`\n        });\n        if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n        if (!params.centeredSlides) {\n            const newSlidesGrid = [];\n            for (let i = 0; i < snapGrid.length; i += 1) {\n                let slidesGridItem = snapGrid[i];\n                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);\n            }\n            snapGrid = newSlidesGrid;\n            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n        if (0 === snapGrid.length) snapGrid = [ 0 ];\n        if (0 !== params.spaceBetween) {\n            const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n            slides.filter(((_, slideIndex) => {\n                if (!params.cssMode) return true;\n                if (slideIndex === slides.length - 1) return false;\n                return true;\n            })).css({\n                [key]: `${spaceBetween}px`\n            });\n        }\n        if (params.centeredSlides && params.centeredSlidesBounds) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue => {\n                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n            }));\n            allSlidesSize -= params.spaceBetween;\n            const maxSnap = allSlidesSize - swiperSize;\n            snapGrid = snapGrid.map((snap => {\n                if (snap < 0) return -offsetBefore;\n                if (snap > maxSnap) return maxSnap + offsetAfter;\n                return snap;\n            }));\n        }\n        if (params.centerInsufficientSlides) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue => {\n                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n            }));\n            allSlidesSize -= params.spaceBetween;\n            if (allSlidesSize < swiperSize) {\n                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n                snapGrid.forEach(((snap, snapIndex) => {\n                    snapGrid[snapIndex] = snap - allSlidesOffset;\n                }));\n                slidesGrid.forEach(((snap, snapIndex) => {\n                    slidesGrid[snapIndex] = snap + allSlidesOffset;\n                }));\n            }\n        }\n        Object.assign(swiper, {\n            slides,\n            snapGrid,\n            slidesGrid,\n            slidesSizesGrid\n        });\n        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n            utils_setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n            utils_setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n            const addToSnapGrid = -swiper.snapGrid[0];\n            const addToSlidesGrid = -swiper.slidesGrid[0];\n            swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));\n            swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));\n        }\n        if (slidesLength !== previousSlidesLength) swiper.emit(\"slidesLengthChange\");\n        if (snapGrid.length !== previousSnapGridLength) {\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            swiper.emit(\"snapGridLengthChange\");\n        }\n        if (slidesGrid.length !== previousSlidesGridLength) swiper.emit(\"slidesGridLengthChange\");\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (!isVirtual && !params.cssMode && (\"slide\" === params.effect || \"fade\" === params.effect)) {\n            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n            const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n            if (slidesLength <= params.maxBackfaceHiddenSlides) {\n                if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);\n            } else if (hasClassBackfaceClassAdded) swiper.$el.removeClass(backFaceHiddenClass);\n        }\n    }\n    function updateAutoHeight(speed) {\n        const swiper = this;\n        const activeSlides = [];\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let newHeight = 0;\n        let i;\n        if (\"number\" === typeof speed) swiper.setTransition(speed); else if (true === speed) swiper.setTransition(swiper.params.speed);\n        const getSlideByIndex = index => {\n            if (isVirtual) return swiper.slides.filter((el => parseInt(el.getAttribute(\"data-swiper-slide-index\"), 10) === index))[0];\n            return swiper.slides.eq(index)[0];\n        };\n        if (\"auto\" !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || dom([])).each((slide => {\n            activeSlides.push(slide);\n        })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n            const index = swiper.activeIndex + i;\n            if (index > swiper.slides.length && !isVirtual) break;\n            activeSlides.push(getSlideByIndex(index));\n        } else activeSlides.push(getSlideByIndex(swiper.activeIndex));\n        for (i = 0; i < activeSlides.length; i += 1) if (\"undefined\" !== typeof activeSlides[i]) {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n        if (newHeight || 0 === newHeight) swiper.$wrapperEl.css(\"height\", `${newHeight}px`);\n    }\n    function updateSlidesOffset() {\n        const swiper = this;\n        const slides = swiper.slides;\n        for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n    }\n    function updateSlidesProgress(translate) {\n        if (void 0 === translate) translate = this && this.translate || 0;\n        const swiper = this;\n        const params = swiper.params;\n        const {slides, rtlTranslate: rtl, snapGrid} = swiper;\n        if (0 === slides.length) return;\n        if (\"undefined\" === typeof slides[0].swiperSlideOffset) swiper.updateSlidesOffset();\n        let offsetCenter = -translate;\n        if (rtl) offsetCenter = translate;\n        slides.removeClass(params.slideVisibleClass);\n        swiper.visibleSlidesIndexes = [];\n        swiper.visibleSlides = [];\n        for (let i = 0; i < slides.length; i += 1) {\n            const slide = slides[i];\n            let slideOffset = slide.swiperSlideOffset;\n            if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;\n            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);\n            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);\n            const slideBefore = -(offsetCenter - slideOffset);\n            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n            if (isVisible) {\n                swiper.visibleSlides.push(slide);\n                swiper.visibleSlidesIndexes.push(i);\n                slides.eq(i).addClass(params.slideVisibleClass);\n            }\n            slide.progress = rtl ? -slideProgress : slideProgress;\n            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n        }\n        swiper.visibleSlides = dom(swiper.visibleSlides);\n    }\n    function updateProgress(translate) {\n        const swiper = this;\n        if (\"undefined\" === typeof translate) {\n            const multiplier = swiper.rtlTranslate ? -1 : 1;\n            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n        }\n        const params = swiper.params;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        let {progress, isBeginning, isEnd} = swiper;\n        const wasBeginning = isBeginning;\n        const wasEnd = isEnd;\n        if (0 === translatesDiff) {\n            progress = 0;\n            isBeginning = true;\n            isEnd = true;\n        } else {\n            progress = (translate - swiper.minTranslate()) / translatesDiff;\n            isBeginning = progress <= 0;\n            isEnd = progress >= 1;\n        }\n        Object.assign(swiper, {\n            progress,\n            isBeginning,\n            isEnd\n        });\n        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n        if (isBeginning && !wasBeginning) swiper.emit(\"reachBeginning toEdge\");\n        if (isEnd && !wasEnd) swiper.emit(\"reachEnd toEdge\");\n        if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit(\"fromEdge\");\n        swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n        const swiper = this;\n        const {slides, params, $wrapperEl, activeIndex, realIndex} = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);\n        let activeSlide;\n        if (isVirtual) activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`); else activeSlide = slides.eq(activeIndex);\n        activeSlide.addClass(params.slideActiveClass);\n        if (params.loop) if (activeSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`).addClass(params.slideDuplicateActiveClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`).addClass(params.slideDuplicateActiveClass);\n        let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n        if (params.loop && 0 === nextSlide.length) {\n            nextSlide = slides.eq(0);\n            nextSlide.addClass(params.slideNextClass);\n        }\n        let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n        if (params.loop && 0 === prevSlide.length) {\n            prevSlide = slides.eq(-1);\n            prevSlide.addClass(params.slidePrevClass);\n        }\n        if (params.loop) {\n            if (nextSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicateNextClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicateNextClass);\n            if (prevSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicatePrevClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicatePrevClass);\n        }\n        swiper.emitSlidesClasses();\n    }\n    function updateActiveIndex(newActiveIndex) {\n        const swiper = this;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        const {slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;\n        let activeIndex = newActiveIndex;\n        let snapIndex;\n        if (\"undefined\" === typeof activeIndex) {\n            for (let i = 0; i < slidesGrid.length; i += 1) if (\"undefined\" !== typeof slidesGrid[i + 1]) {\n                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;\n            } else if (translate >= slidesGrid[i]) activeIndex = i;\n            if (params.normalizeSlideIndex) if (activeIndex < 0 || \"undefined\" === typeof activeIndex) activeIndex = 0;\n        }\n        if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {\n            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n        }\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if (activeIndex === previousIndex) {\n            if (snapIndex !== previousSnapIndex) {\n                swiper.snapIndex = snapIndex;\n                swiper.emit(\"snapIndexChange\");\n            }\n            return;\n        }\n        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr(\"data-swiper-slide-index\") || activeIndex, 10);\n        Object.assign(swiper, {\n            snapIndex,\n            realIndex,\n            previousIndex,\n            activeIndex\n        });\n        swiper.emit(\"activeIndexChange\");\n        swiper.emit(\"snapIndexChange\");\n        if (previousRealIndex !== realIndex) swiper.emit(\"realIndexChange\");\n        if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit(\"slideChange\");\n    }\n    function updateClickedSlide(e) {\n        const swiper = this;\n        const params = swiper.params;\n        const slide = dom(e).closest(`.${params.slideClass}`)[0];\n        let slideFound = false;\n        let slideIndex;\n        if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {\n            slideFound = true;\n            slideIndex = i;\n            break;\n        }\n        if (slide && slideFound) {\n            swiper.clickedSlide = slide;\n            if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(dom(slide).attr(\"data-swiper-slide-index\"), 10); else swiper.clickedIndex = slideIndex;\n        } else {\n            swiper.clickedSlide = void 0;\n            swiper.clickedIndex = void 0;\n            return;\n        }\n        if (params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();\n    }\n    const update = {\n        updateSize,\n        updateSlides,\n        updateAutoHeight,\n        updateSlidesOffset,\n        updateSlidesProgress,\n        updateProgress,\n        updateSlidesClasses,\n        updateActiveIndex,\n        updateClickedSlide\n    };\n    function getSwiperTranslate(axis) {\n        if (void 0 === axis) axis = this.isHorizontal() ? \"x\" : \"y\";\n        const swiper = this;\n        const {params, rtlTranslate: rtl, translate, $wrapperEl} = swiper;\n        if (params.virtualTranslate) return rtl ? -translate : translate;\n        if (params.cssMode) return translate;\n        let currentTranslate = utils_getTranslate($wrapperEl[0], axis);\n        if (rtl) currentTranslate = -currentTranslate;\n        return currentTranslate || 0;\n    }\n    function setTranslate(translate, byController) {\n        const swiper = this;\n        const {rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress} = swiper;\n        let x = 0;\n        let y = 0;\n        const z = 0;\n        if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;\n        if (params.roundLengths) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n        }\n        if (params.cssMode) wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n        swiper.previousTranslate = swiper.translate;\n        swiper.translate = swiper.isHorizontal() ? x : y;\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (0 === translatesDiff) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== progress) swiper.updateProgress(translate);\n        swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n        return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n        if (void 0 === translate) translate = 0;\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        if (void 0 === translateBounds) translateBounds = true;\n        const swiper = this;\n        const {params, wrapperEl} = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition) return false;\n        const minTranslate = swiper.minTranslate();\n        const maxTranslate = swiper.maxTranslate();\n        let newTranslate;\n        if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;\n        swiper.updateProgress(newTranslate);\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            if (0 === speed) wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate; else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper,\n                        targetPosition: -newTranslate,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: -newTranslate,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        if (0 === speed) {\n            swiper.setTransition(0);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionEnd\");\n            }\n        } else {\n            swiper.setTransition(speed);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionStart\");\n            }\n            if (!swiper.animating) {\n                swiper.animating = true;\n                if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.$wrapperEl[0].removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    if (runCallbacks) swiper.emit(\"transitionEnd\");\n                };\n                swiper.$wrapperEl[0].addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                swiper.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", swiper.onTranslateToWrapperTransitionEnd);\n            }\n        }\n        return true;\n    }\n    const translate = {\n        getTranslate: getSwiperTranslate,\n        setTranslate,\n        minTranslate,\n        maxTranslate,\n        translateTo\n    };\n    function setTransition(duration, byController) {\n        const swiper = this;\n        if (!swiper.params.cssMode) swiper.$wrapperEl.transition(duration);\n        swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit(_ref) {\n        let {swiper, runCallbacks, direction, step} = _ref;\n        const {activeIndex, previousIndex} = swiper;\n        let dir = direction;\n        if (!dir) if (activeIndex > previousIndex) dir = \"next\"; else if (activeIndex < previousIndex) dir = \"prev\"; else dir = \"reset\";\n        swiper.emit(`transition${step}`);\n        if (runCallbacks && activeIndex !== previousIndex) {\n            if (\"reset\" === dir) {\n                swiper.emit(`slideResetTransition${step}`);\n                return;\n            }\n            swiper.emit(`slideChangeTransition${step}`);\n            if (\"next\" === dir) swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n    function transitionStart(runCallbacks, direction) {\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        const {params} = swiper;\n        if (params.cssMode) return;\n        if (params.autoHeight) swiper.updateAutoHeight();\n        transitionEmit({\n            swiper,\n            runCallbacks,\n            direction,\n            step: \"Start\"\n        });\n    }\n    function transitionEnd_transitionEnd(runCallbacks, direction) {\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        const {params} = swiper;\n        swiper.animating = false;\n        if (params.cssMode) return;\n        swiper.setTransition(0);\n        transitionEmit({\n            swiper,\n            runCallbacks,\n            direction,\n            step: \"End\"\n        });\n    }\n    const core_transition = {\n        setTransition,\n        transitionStart,\n        transitionEnd: transitionEnd_transitionEnd\n    };\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n        if (void 0 === index) index = 0;\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        if (\"number\" !== typeof index && \"string\" !== typeof index) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);\n        if (\"string\" === typeof index) {\n            const indexAsNumber = parseInt(index, 10);\n            const isValidNumber = isFinite(indexAsNumber);\n            if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n            index = indexAsNumber;\n        }\n        const swiper = this;\n        let slideIndex = index;\n        if (slideIndex < 0) slideIndex = 0;\n        const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) swiper.emit(\"beforeSlideChangeStart\");\n        const translate = -snapGrid[snapIndex];\n        swiper.updateProgress(translate);\n        if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {\n            const normalizedTranslate = -Math.floor(100 * translate);\n            const normalizedGrid = Math.floor(100 * slidesGrid[i]);\n            const normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);\n            if (\"undefined\" !== typeof slidesGrid[i + 1]) {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;\n            } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;\n        }\n        if (swiper.initialized && slideIndex !== activeIndex) {\n            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;\n            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;\n        }\n        let direction;\n        if (slideIndex > activeIndex) direction = \"next\"; else if (slideIndex < activeIndex) direction = \"prev\"; else direction = \"reset\";\n        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n            swiper.updateActiveIndex(slideIndex);\n            if (params.autoHeight) swiper.updateAutoHeight();\n            swiper.updateSlidesClasses();\n            if (\"slide\" !== params.effect) swiper.setTranslate(translate);\n            if (\"reset\" !== direction) {\n                swiper.transitionStart(runCallbacks, direction);\n                swiper.transitionEnd(runCallbacks, direction);\n            }\n            return false;\n        }\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            const t = rtl ? translate : -translate;\n            if (0 === speed) {\n                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n                if (isVirtual) {\n                    swiper.wrapperEl.style.scrollSnapType = \"none\";\n                    swiper._immediateVirtual = true;\n                }\n                wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                if (isVirtual) requestAnimationFrame((() => {\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._swiperImmediateVirtual = false;\n                }));\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper,\n                        targetPosition: t,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: t,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        swiper.setTransition(speed);\n        swiper.setTranslate(translate);\n        swiper.updateActiveIndex(slideIndex);\n        swiper.updateSlidesClasses();\n        swiper.emit(\"beforeTransitionStart\", speed, internal);\n        swiper.transitionStart(runCallbacks, direction);\n        if (0 === speed) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.$wrapperEl[0].removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n            swiper.$wrapperEl[0].addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n            swiper.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", swiper.onSlideToWrapperTransitionEnd);\n        }\n        return true;\n    }\n    function slideToLoop(index, speed, runCallbacks, internal) {\n        if (void 0 === index) index = 0;\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        let newIndex = index;\n        if (swiper.params.loop) newIndex += swiper.loopedSlides;\n        return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    function slideNext(speed, runCallbacks, internal) {\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        const {animating, enabled, params} = swiper;\n        if (!enabled) return swiper;\n        let perGroup = params.slidesPerGroup;\n        if (\"auto\" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n        if (params.loop) {\n            if (animating && params.loopPreventsSlide) return false;\n            swiper.loopFix();\n            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        }\n        if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);\n        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n    function slidePrev(speed, runCallbacks, internal) {\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        const {params, animating, snapGrid, slidesGrid, rtlTranslate, enabled} = swiper;\n        if (!enabled) return swiper;\n        if (params.loop) {\n            if (animating && params.loopPreventsSlide) return false;\n            swiper.loopFix();\n            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        }\n        const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n        function normalize(val) {\n            if (val < 0) return -Math.floor(Math.abs(val));\n            return Math.floor(val);\n        }\n        const normalizedTranslate = normalize(translate);\n        const normalizedSnapGrid = snapGrid.map((val => normalize(val)));\n        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n        if (\"undefined\" === typeof prevSnap && params.cssMode) {\n            let prevSnapIndex;\n            snapGrid.forEach(((snap, snapIndex) => {\n                if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;\n            }));\n            if (\"undefined\" !== typeof prevSnapIndex) prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n        let prevIndex = 0;\n        if (\"undefined\" !== typeof prevSnap) {\n            prevIndex = slidesGrid.indexOf(prevSnap);\n            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n            if (\"auto\" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) {\n                prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n                prevIndex = Math.max(prevIndex, 0);\n            }\n        }\n        if (params.rewind && swiper.isBeginning) {\n            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n        }\n        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    function slideReset(speed, runCallbacks, internal) {\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        const swiper = this;\n        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    function slideToClosest(speed, runCallbacks, internal, threshold) {\n        if (void 0 === speed) speed = this.params.speed;\n        if (void 0 === runCallbacks) runCallbacks = true;\n        if (void 0 === threshold) threshold = .5;\n        const swiper = this;\n        let index = swiper.activeIndex;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        if (translate >= swiper.snapGrid[snapIndex]) {\n            const currentSnap = swiper.snapGrid[snapIndex];\n            const nextSnap = swiper.snapGrid[snapIndex + 1];\n            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;\n        } else {\n            const prevSnap = swiper.snapGrid[snapIndex - 1];\n            const currentSnap = swiper.snapGrid[snapIndex];\n            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;\n        }\n        index = Math.max(index, 0);\n        index = Math.min(index, swiper.slidesGrid.length - 1);\n        return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n        const swiper = this;\n        const {params, $wrapperEl} = swiper;\n        const slidesPerView = \"auto\" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n        let slideToIndex = swiper.clickedIndex;\n        let realIndex;\n        if (params.loop) {\n            if (swiper.animating) return;\n            realIndex = parseInt(dom(swiper.clickedSlide).attr(\"data-swiper-slide-index\"), 10);\n            if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                swiper.loopFix();\n                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`).eq(0).index();\n                utils_nextTick((() => {\n                    swiper.slideTo(slideToIndex);\n                }));\n            } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {\n                swiper.loopFix();\n                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`).eq(0).index();\n                utils_nextTick((() => {\n                    swiper.slideTo(slideToIndex);\n                }));\n            } else swiper.slideTo(slideToIndex);\n        } else swiper.slideTo(slideToIndex);\n    }\n    const slide = {\n        slideTo,\n        slideToLoop,\n        slideNext,\n        slidePrev,\n        slideReset,\n        slideToClosest,\n        slideToClickedSlide\n    };\n    function loopCreate() {\n        const swiper = this;\n        const document = ssr_window_esm_getDocument();\n        const {params, $wrapperEl} = swiper;\n        const $selector = $wrapperEl.children().length > 0 ? dom($wrapperEl.children()[0].parentNode) : $wrapperEl;\n        $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n        let slides = $selector.children(`.${params.slideClass}`);\n        if (params.loopFillGroupWithBlank) {\n            const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;\n            if (blankSlidesNum !== params.slidesPerGroup) {\n                for (let i = 0; i < blankSlidesNum; i += 1) {\n                    const blankNode = dom(document.createElement(\"div\")).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n                    $selector.append(blankNode);\n                }\n                slides = $selector.children(`.${params.slideClass}`);\n            }\n        }\n        if (\"auto\" === params.slidesPerView && !params.loopedSlides) params.loopedSlides = slides.length;\n        swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n        swiper.loopedSlides += params.loopAdditionalSlides;\n        if (swiper.loopedSlides > slides.length) swiper.loopedSlides = slides.length;\n        const prependSlides = [];\n        const appendSlides = [];\n        slides.each(((el, index) => {\n            const slide = dom(el);\n            if (index < swiper.loopedSlides) appendSlides.push(el);\n            if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);\n            slide.attr(\"data-swiper-slide-index\", index);\n        }));\n        for (let i = 0; i < appendSlides.length; i += 1) $selector.append(dom(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n        for (let i = prependSlides.length - 1; i >= 0; i -= 1) $selector.prepend(dom(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n    }\n    function loopFix() {\n        const swiper = this;\n        swiper.emit(\"beforeLoopFix\");\n        const {activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl} = swiper;\n        let newIndex;\n        swiper.allowSlidePrev = true;\n        swiper.allowSlideNext = true;\n        const snapTranslate = -snapGrid[activeIndex];\n        const diff = snapTranslate - swiper.getTranslate();\n        if (activeIndex < loopedSlides) {\n            newIndex = slides.length - 3 * loopedSlides + activeIndex;\n            newIndex += loopedSlides;\n            const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n            if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n        } else if (activeIndex >= slides.length - loopedSlides) {\n            newIndex = -slides.length + activeIndex + loopedSlides;\n            newIndex += loopedSlides;\n            const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n            if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n        const swiper = this;\n        const {$wrapperEl, params, slides} = swiper;\n        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();\n        slides.removeAttr(\"data-swiper-slide-index\");\n    }\n    const loop = {\n        loopCreate,\n        loopFix,\n        loopDestroy\n    };\n    function setGrabCursor(moving) {\n        const swiper = this;\n        if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        const el = \"container\" === swiper.params.touchEventsTarget ? swiper.el : swiper.wrapperEl;\n        el.style.cursor = \"move\";\n        el.style.cursor = moving ? \"grabbing\" : \"grab\";\n    }\n    function unsetGrabCursor() {\n        const swiper = this;\n        if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        swiper[\"container\" === swiper.params.touchEventsTarget ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n    }\n    const grab_cursor = {\n        setGrabCursor,\n        unsetGrabCursor\n    };\n    function closestElement(selector, base) {\n        if (void 0 === base) base = this;\n        function __closestFrom(el) {\n            if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;\n            if (el.assignedSlot) el = el.assignedSlot;\n            const found = el.closest(selector);\n            if (!found && !el.getRootNode) return null;\n            return found || __closestFrom(el.getRootNode().host);\n        }\n        return __closestFrom(base);\n    }\n    function onTouchStart(event) {\n        const swiper = this;\n        const document = ssr_window_esm_getDocument();\n        const window = ssr_window_esm_getWindow();\n        const data = swiper.touchEventsData;\n        const {params, touches, enabled} = swiper;\n        if (!enabled) return;\n        if (swiper.animating && params.preventInteractionOnTransition) return;\n        if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        let $targetEl = dom(e.target);\n        if (\"wrapper\" === params.touchEventsTarget) if (!$targetEl.closest(swiper.wrapperEl).length) return;\n        data.isTouchEvent = \"touchstart\" === e.type;\n        if (!data.isTouchEvent && \"which\" in e && 3 === e.which) return;\n        if (!data.isTouchEvent && \"button\" in e && e.button > 0) return;\n        if (data.isTouched && data.isMoved) return;\n        const swipingClassHasValue = !!params.noSwipingClass && \"\" !== params.noSwipingClass;\n        if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) $targetEl = dom(event.path[0]);\n        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n        const isTargetShadow = !!(e.target && e.target.shadowRoot);\n        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {\n            swiper.allowClick = true;\n            return;\n        }\n        if (params.swipeHandler) if (!$targetEl.closest(params.swipeHandler)[0]) return;\n        touches.currentX = \"touchstart\" === e.type ? e.targetTouches[0].pageX : e.pageX;\n        touches.currentY = \"touchstart\" === e.type ? e.targetTouches[0].pageY : e.pageY;\n        const startX = touches.currentX;\n        const startY = touches.currentY;\n        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if (\"prevent\" === edgeSwipeDetection) event.preventDefault(); else return;\n        Object.assign(data, {\n            isTouched: true,\n            isMoved: false,\n            allowTouchCallbacks: true,\n            isScrolling: void 0,\n            startMoving: void 0\n        });\n        touches.startX = startX;\n        touches.startY = startY;\n        data.touchStartTime = utils_now();\n        swiper.allowClick = true;\n        swiper.updateSize();\n        swiper.swipeDirection = void 0;\n        if (params.threshold > 0) data.allowThresholdMove = false;\n        if (\"touchstart\" !== e.type) {\n            let preventDefault = true;\n            if ($targetEl.is(data.focusableElements)) {\n                preventDefault = false;\n                if (\"SELECT\" === $targetEl[0].nodeName) data.isTouched = false;\n            }\n            if (document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) document.activeElement.blur();\n            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) e.preventDefault();\n        }\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();\n        swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event) {\n        const document = ssr_window_esm_getDocument();\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const {params, touches, rtlTranslate: rtl, enabled} = swiper;\n        if (!enabled) return;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        if (!data.isTouched) {\n            if (data.startMoving && data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n            return;\n        }\n        if (data.isTouchEvent && \"touchmove\" !== e.type) return;\n        const targetTouch = \"touchmove\" === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n        const pageX = \"touchmove\" === e.type ? targetTouch.pageX : e.pageX;\n        const pageY = \"touchmove\" === e.type ? targetTouch.pageY : e.pageY;\n        if (e.preventedByNestedSwiper) {\n            touches.startX = pageX;\n            touches.startY = pageY;\n            return;\n        }\n        if (!swiper.allowTouchMove) {\n            if (!dom(e.target).is(data.focusableElements)) swiper.allowClick = false;\n            if (data.isTouched) {\n                Object.assign(touches, {\n                    startX: pageX,\n                    startY: pageY,\n                    currentX: pageX,\n                    currentY: pageY\n                });\n                data.touchStartTime = utils_now();\n            }\n            return;\n        }\n        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {\n            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                data.isTouched = false;\n                data.isMoved = false;\n                return;\n            }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;\n        if (data.isTouchEvent && document.activeElement) if (e.target === document.activeElement && dom(e.target).is(data.focusableElements)) {\n            data.isMoved = true;\n            swiper.allowClick = false;\n            return;\n        }\n        if (data.allowTouchCallbacks) swiper.emit(\"touchMove\", e);\n        if (e.targetTouches && e.targetTouches.length > 1) return;\n        touches.currentX = pageX;\n        touches.currentY = pageY;\n        const diffX = touches.currentX - touches.startX;\n        const diffY = touches.currentY - touches.startY;\n        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n        if (\"undefined\" === typeof data.isScrolling) {\n            let touchAngle;\n            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n        if (data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n        if (\"undefined\" === typeof data.startMoving) if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;\n        if (data.isScrolling) {\n            data.isTouched = false;\n            return;\n        }\n        if (!data.startMoving) return;\n        swiper.allowClick = false;\n        if (!params.cssMode && e.cancelable) e.preventDefault();\n        if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();\n        if (!data.isMoved) {\n            if (params.loop && !params.cssMode) swiper.loopFix();\n            data.startTranslate = swiper.getTranslate();\n            swiper.setTransition(0);\n            if (swiper.animating) swiper.$wrapperEl.trigger(\"webkitTransitionEnd transitionend\");\n            data.allowMomentumBounce = false;\n            if (params.grabCursor && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(true);\n            swiper.emit(\"sliderFirstMove\", e);\n        }\n        swiper.emit(\"sliderMove\", e);\n        data.isMoved = true;\n        let diff = swiper.isHorizontal() ? diffX : diffY;\n        touches.diff = diff;\n        diff *= params.touchRatio;\n        if (rtl) diff = -diff;\n        swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n        data.currentTranslate = diff + data.startTranslate;\n        let disableParentSwiper = true;\n        let resistanceRatio = params.resistanceRatio;\n        if (params.touchReleaseOnEdges) resistanceRatio = 0;\n        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n        }\n        if (disableParentSwiper) e.preventedByNestedSwiper = true;\n        if (!swiper.allowSlideNext && \"next\" === swiper.swipeDirection && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && \"prev\" === swiper.swipeDirection && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;\n        if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n            if (!data.allowThresholdMove) {\n                data.allowThresholdMove = true;\n                touches.startX = touches.currentX;\n                touches.startY = touches.currentY;\n                data.currentTranslate = data.startTranslate;\n                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                return;\n            }\n        } else {\n            data.currentTranslate = data.startTranslate;\n            return;\n        }\n        if (!params.followFinger || params.cssMode) return;\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();\n        swiper.updateProgress(data.currentTranslate);\n        swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event) {\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;\n        if (!enabled) return;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        if (data.allowTouchCallbacks) swiper.emit(\"touchEnd\", e);\n        data.allowTouchCallbacks = false;\n        if (!data.isTouched) {\n            if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        if (params.grabCursor && data.isMoved && data.isTouched && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(false);\n        const touchEndTime = utils_now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        if (swiper.allowClick) {\n            const pathTree = e.path || e.composedPath && e.composedPath();\n            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n            swiper.emit(\"tap click\", e);\n            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit(\"doubleTap doubleClick\", e);\n        }\n        data.lastClickTime = utils_now();\n        utils_nextTick((() => {\n            if (!swiper.destroyed) swiper.allowClick = true;\n        }));\n        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) {\n            data.isTouched = false;\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        let currentPos;\n        if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;\n        if (params.cssMode) return;\n        if (swiper.params.freeMode && params.freeMode.enabled) {\n            swiper.freeMode.onTouchEnd({\n                currentPos\n            });\n            return;\n        }\n        let stopIndex = 0;\n        let groupSize = swiper.slidesSizesGrid[0];\n        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n            if (\"undefined\" !== typeof slidesGrid[i + increment]) {\n                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                    stopIndex = i;\n                    groupSize = slidesGrid[i + increment] - slidesGrid[i];\n                }\n            } else if (currentPos >= slidesGrid[i]) {\n                stopIndex = i;\n                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n            }\n        }\n        let rewindFirstIndex = null;\n        let rewindLastIndex = null;\n        if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;\n        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (timeDiff > params.longSwipesMs) {\n            if (!params.longSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (\"next\" === swiper.swipeDirection) if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);\n            if (\"prev\" === swiper.swipeDirection) if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (null !== rewindLastIndex && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);\n        } else {\n            if (!params.shortSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n            if (!isNavButtonTarget) {\n                if (\"next\" === swiper.swipeDirection) swiper.slideTo(null !== rewindFirstIndex ? rewindFirstIndex : stopIndex + increment);\n                if (\"prev\" === swiper.swipeDirection) swiper.slideTo(null !== rewindLastIndex ? rewindLastIndex : stopIndex);\n            } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);\n        }\n    }\n    function onResize() {\n        const swiper = this;\n        const {params, el} = swiper;\n        if (el && 0 === el.offsetWidth) return;\n        if (params.breakpoints) swiper.setBreakpoint();\n        const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;\n        swiper.allowSlideNext = true;\n        swiper.allowSlidePrev = true;\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateSlidesClasses();\n        if ((\"auto\" === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.run();\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n    }\n    function onClick(e) {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        if (!swiper.allowClick) {\n            if (swiper.params.preventClicks) e.preventDefault();\n            if (swiper.params.preventClicksPropagation && swiper.animating) {\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n    }\n    function onScroll() {\n        const swiper = this;\n        const {wrapperEl, rtlTranslate, enabled} = swiper;\n        if (!enabled) return;\n        swiper.previousTranslate = swiper.translate;\n        if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;\n        if (0 === swiper.translate) swiper.translate = 0;\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (0 === translatesDiff) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n        swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method) => {\n        const document = ssr_window_esm_getDocument();\n        const {params, touchEvents, el, wrapperEl, device, support} = swiper;\n        const capture = !!params.nested;\n        const domMethod = \"on\" === method ? \"addEventListener\" : \"removeEventListener\";\n        const swiperMethod = method;\n        if (!support.touch) {\n            el[domMethod](touchEvents.start, swiper.onTouchStart, false);\n            document[domMethod](touchEvents.move, swiper.onTouchMove, capture);\n            document[domMethod](touchEvents.end, swiper.onTouchEnd, false);\n        } else {\n            const passiveListener = \"touchstart\" === touchEvents.start && support.passiveListener && params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\n            el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {\n                passive: false,\n                capture\n            } : capture);\n            el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\n            if (touchEvents.cancel) el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n        }\n        if (params.preventClicks || params.preventClicksPropagation) el[domMethod](\"click\", swiper.onClick, true);\n        if (params.cssMode) wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n        if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true); else swiper[swiperMethod](\"observerUpdate\", onResize, true);\n    };\n    function attachEvents() {\n        const swiper = this;\n        const document = ssr_window_esm_getDocument();\n        const {params, support} = swiper;\n        swiper.onTouchStart = onTouchStart.bind(swiper);\n        swiper.onTouchMove = onTouchMove.bind(swiper);\n        swiper.onTouchEnd = onTouchEnd.bind(swiper);\n        if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);\n        swiper.onClick = onClick.bind(swiper);\n        if (support.touch && !dummyEventAttached) {\n            document.addEventListener(\"touchstart\", dummyEventListener);\n            dummyEventAttached = true;\n        }\n        events(swiper, \"on\");\n    }\n    function detachEvents() {\n        const swiper = this;\n        events(swiper, \"off\");\n    }\n    const core_events = {\n        attachEvents,\n        detachEvents\n    };\n    const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;\n    function setBreakpoint() {\n        const swiper = this;\n        const {activeIndex, initialized, loopedSlides = 0, params, $el} = swiper;\n        const breakpoints = params.breakpoints;\n        if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length) return;\n        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;\n        const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n        const wasMultiRow = isGridEnabled(swiper, params);\n        const isMultiRow = isGridEnabled(swiper, breakpointParams);\n        const wasEnabled = params.enabled;\n        if (wasMultiRow && !isMultiRow) {\n            $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        } else if (!wasMultiRow && isMultiRow) {\n            $el.addClass(`${params.containerModifierClass}grid`);\n            if (breakpointParams.grid.fill && \"column\" === breakpointParams.grid.fill || !breakpointParams.grid.fill && \"column\" === params.grid.fill) $el.addClass(`${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        }\n        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n        if (directionChanged && initialized) swiper.changeDirection();\n        utils_extend(swiper.params, breakpointParams);\n        const isEnabled = swiper.params.enabled;\n        Object.assign(swiper, {\n            allowTouchMove: swiper.params.allowTouchMove,\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev\n        });\n        if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();\n        swiper.currentBreakpoint = breakpoint;\n        swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n        if (needsReLoop && initialized) {\n            swiper.loopDestroy();\n            swiper.loopCreate();\n            swiper.updateSlides();\n            swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n        }\n        swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints, base, containerEl) {\n        if (void 0 === base) base = \"window\";\n        if (!breakpoints || \"container\" === base && !containerEl) return;\n        let breakpoint = false;\n        const window = ssr_window_esm_getWindow();\n        const currentHeight = \"window\" === base ? window.innerHeight : containerEl.clientHeight;\n        const points = Object.keys(breakpoints).map((point => {\n            if (\"string\" === typeof point && 0 === point.indexOf(\"@\")) {\n                const minRatio = parseFloat(point.substr(1));\n                const value = currentHeight * minRatio;\n                return {\n                    value,\n                    point\n                };\n            }\n            return {\n                value: point,\n                point\n            };\n        }));\n        points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));\n        for (let i = 0; i < points.length; i += 1) {\n            const {point, value} = points[i];\n            if (\"window\" === base) {\n                if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;\n            } else if (value <= containerEl.clientWidth) breakpoint = point;\n        }\n        return breakpoint || \"max\";\n    }\n    const breakpoints = {\n        setBreakpoint,\n        getBreakpoint\n    };\n    function prepareClasses(entries, prefix) {\n        const resultClasses = [];\n        entries.forEach((item => {\n            if (\"object\" === typeof item) Object.keys(item).forEach((classNames => {\n                if (item[classNames]) resultClasses.push(prefix + classNames);\n            })); else if (\"string\" === typeof item) resultClasses.push(prefix + item);\n        }));\n        return resultClasses;\n    }\n    function addClasses() {\n        const swiper = this;\n        const {classNames, params, rtl, $el, device, support} = swiper;\n        const suffixes = prepareClasses([ \"initialized\", params.direction, {\n            \"pointer-events\": !support.touch\n        }, {\n            \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n        }, {\n            autoheight: params.autoHeight\n        }, {\n            rtl\n        }, {\n            grid: params.grid && params.grid.rows > 1\n        }, {\n            \"grid-column\": params.grid && params.grid.rows > 1 && \"column\" === params.grid.fill\n        }, {\n            android: device.android\n        }, {\n            ios: device.ios\n        }, {\n            \"css-mode\": params.cssMode\n        }, {\n            centered: params.cssMode && params.centeredSlides\n        }, {\n            \"watch-progress\": params.watchSlidesProgress\n        } ], params.containerModifierClass);\n        classNames.push(...suffixes);\n        $el.addClass([ ...classNames ].join(\" \"));\n        swiper.emitContainerClasses();\n    }\n    function removeClasses_removeClasses() {\n        const swiper = this;\n        const {$el, classNames} = swiper;\n        $el.removeClass(classNames.join(\" \"));\n        swiper.emitContainerClasses();\n    }\n    const classes = {\n        addClasses,\n        removeClasses: removeClasses_removeClasses\n    };\n    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n        const window = ssr_window_esm_getWindow();\n        let image;\n        function onReady() {\n            if (callback) callback();\n        }\n        const isPicture = dom(imageEl).parent(\"picture\")[0];\n        if (!isPicture && (!imageEl.complete || !checkForComplete)) if (src) {\n            image = new window.Image;\n            image.onload = onReady;\n            image.onerror = onReady;\n            if (sizes) image.sizes = sizes;\n            if (srcset) image.srcset = srcset;\n            if (src) image.src = src;\n        } else onReady(); else onReady();\n    }\n    function preloadImages() {\n        const swiper = this;\n        swiper.imagesToLoad = swiper.$el.find(\"img\");\n        function onReady() {\n            if (\"undefined\" === typeof swiper || null === swiper || !swiper || swiper.destroyed) return;\n            if (void 0 !== swiper.imagesLoaded) swiper.imagesLoaded += 1;\n            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n                if (swiper.params.updateOnImagesReady) swiper.update();\n                swiper.emit(\"imagesReady\");\n            }\n        }\n        for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n            const imageEl = swiper.imagesToLoad[i];\n            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute(\"src\"), imageEl.srcset || imageEl.getAttribute(\"srcset\"), imageEl.sizes || imageEl.getAttribute(\"sizes\"), true, onReady);\n        }\n    }\n    const core_images = {\n        loadImage,\n        preloadImages\n    };\n    function checkOverflow() {\n        const swiper = this;\n        const {isLocked: wasLocked, params} = swiper;\n        const {slidesOffsetBefore} = params;\n        if (slidesOffsetBefore) {\n            const lastSlideIndex = swiper.slides.length - 1;\n            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;\n            swiper.isLocked = swiper.size > lastSlideRightEdge;\n        } else swiper.isLocked = 1 === swiper.snapGrid.length;\n        if (true === params.allowSlideNext) swiper.allowSlideNext = !swiper.isLocked;\n        if (true === params.allowSlidePrev) swiper.allowSlidePrev = !swiper.isLocked;\n        if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;\n        if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n    const check_overflow = {\n        checkOverflow\n    };\n    const defaults = {\n        init: true,\n        direction: \"horizontal\",\n        touchEventsTarget: \"wrapper\",\n        initialSlide: 0,\n        speed: 300,\n        cssMode: false,\n        updateOnWindowResize: true,\n        resizeObserver: true,\n        nested: false,\n        createElements: false,\n        enabled: true,\n        focusableElements: \"input, select, option, textarea, button, video, label\",\n        width: null,\n        height: null,\n        preventInteractionOnTransition: false,\n        userAgent: null,\n        url: null,\n        edgeSwipeDetection: false,\n        edgeSwipeThreshold: 20,\n        autoHeight: false,\n        setWrapperSize: false,\n        virtualTranslate: false,\n        effect: \"slide\",\n        breakpoints: void 0,\n        breakpointsBase: \"window\",\n        spaceBetween: 0,\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        slidesPerGroupSkip: 0,\n        slidesPerGroupAuto: false,\n        centeredSlides: false,\n        centeredSlidesBounds: false,\n        slidesOffsetBefore: 0,\n        slidesOffsetAfter: 0,\n        normalizeSlideIndex: true,\n        centerInsufficientSlides: false,\n        watchOverflow: true,\n        roundLengths: false,\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: .5,\n        longSwipesMs: 300,\n        followFinger: true,\n        allowTouchMove: true,\n        threshold: 0,\n        touchMoveStopPropagation: false,\n        touchStartPreventDefault: true,\n        touchStartForcePreventDefault: false,\n        touchReleaseOnEdges: false,\n        uniqueNavElements: true,\n        resistance: true,\n        resistanceRatio: .85,\n        watchSlidesProgress: false,\n        grabCursor: false,\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        preloadImages: true,\n        updateOnImagesReady: true,\n        loop: false,\n        loopAdditionalSlides: 0,\n        loopedSlides: null,\n        loopFillGroupWithBlank: false,\n        loopPreventsSlide: true,\n        rewind: false,\n        allowSlidePrev: true,\n        allowSlideNext: true,\n        swipeHandler: null,\n        noSwiping: true,\n        noSwipingClass: \"swiper-no-swiping\",\n        noSwipingSelector: null,\n        passiveListeners: true,\n        maxBackfaceHiddenSlides: 10,\n        containerModifierClass: \"swiper-\",\n        slideClass: \"swiper-slide\",\n        slideBlankClass: \"swiper-slide-invisible-blank\",\n        slideActiveClass: \"swiper-slide-active\",\n        slideDuplicateActiveClass: \"swiper-slide-duplicate-active\",\n        slideVisibleClass: \"swiper-slide-visible\",\n        slideDuplicateClass: \"swiper-slide-duplicate\",\n        slideNextClass: \"swiper-slide-next\",\n        slideDuplicateNextClass: \"swiper-slide-duplicate-next\",\n        slidePrevClass: \"swiper-slide-prev\",\n        slideDuplicatePrevClass: \"swiper-slide-duplicate-prev\",\n        wrapperClass: \"swiper-wrapper\",\n        runCallbacksOnInit: true,\n        _emitClasses: false\n    };\n    function moduleExtendParams(params, allModulesParams) {\n        return function extendParams(obj) {\n            if (void 0 === obj) obj = {};\n            const moduleParamName = Object.keys(obj)[0];\n            const moduleParams = obj[moduleParamName];\n            if (\"object\" !== typeof moduleParams || null === moduleParams) {\n                utils_extend(allModulesParams, obj);\n                return;\n            }\n            if ([ \"navigation\", \"pagination\", \"scrollbar\" ].indexOf(moduleParamName) >= 0 && true === params[moduleParamName]) params[moduleParamName] = {\n                auto: true\n            };\n            if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n                utils_extend(allModulesParams, obj);\n                return;\n            }\n            if (true === params[moduleParamName]) params[moduleParamName] = {\n                enabled: true\n            };\n            if (\"object\" === typeof params[moduleParamName] && !(\"enabled\" in params[moduleParamName])) params[moduleParamName].enabled = true;\n            if (!params[moduleParamName]) params[moduleParamName] = {\n                enabled: false\n            };\n            utils_extend(allModulesParams, obj);\n        };\n    }\n    const prototypes = {\n        eventsEmitter: events_emitter,\n        update,\n        translate,\n        transition: core_transition,\n        slide,\n        loop,\n        grabCursor: grab_cursor,\n        events: core_events,\n        breakpoints,\n        checkOverflow: check_overflow,\n        classes,\n        images: core_images\n    };\n    const extendedDefaults = {};\n    class core_Swiper {\n        constructor() {\n            let el;\n            let params;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n            if (1 === args.length && args[0].constructor && \"Object\" === Object.prototype.toString.call(args[0]).slice(8, -1)) params = args[0]; else [el, params] = args;\n            if (!params) params = {};\n            params = utils_extend({}, params);\n            if (el && !params.el) params.el = el;\n            if (params.el && dom(params.el).length > 1) {\n                const swipers = [];\n                dom(params.el).each((containerEl => {\n                    const newParams = utils_extend({}, params, {\n                        el: containerEl\n                    });\n                    swipers.push(new core_Swiper(newParams));\n                }));\n                return swipers;\n            }\n            const swiper = this;\n            swiper.__swiper__ = true;\n            swiper.support = getSupport();\n            swiper.device = getDevice({\n                userAgent: params.userAgent\n            });\n            swiper.browser = getBrowser();\n            swiper.eventsListeners = {};\n            swiper.eventsAnyListeners = [];\n            swiper.modules = [ ...swiper.__modules__ ];\n            if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);\n            const allModulesParams = {};\n            swiper.modules.forEach((mod => {\n                mod({\n                    swiper,\n                    extendParams: moduleExtendParams(params, allModulesParams),\n                    on: swiper.on.bind(swiper),\n                    once: swiper.once.bind(swiper),\n                    off: swiper.off.bind(swiper),\n                    emit: swiper.emit.bind(swiper)\n                });\n            }));\n            const swiperParams = utils_extend({}, defaults, allModulesParams);\n            swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);\n            swiper.originalParams = utils_extend({}, swiper.params);\n            swiper.passedParams = utils_extend({}, params);\n            if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {\n                swiper.on(eventName, swiper.params.on[eventName]);\n            }));\n            if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);\n            swiper.$ = dom;\n            Object.assign(swiper, {\n                enabled: swiper.params.enabled,\n                el,\n                classNames: [],\n                slides: dom(),\n                slidesGrid: [],\n                snapGrid: [],\n                slidesSizesGrid: [],\n                isHorizontal() {\n                    return \"horizontal\" === swiper.params.direction;\n                },\n                isVertical() {\n                    return \"vertical\" === swiper.params.direction;\n                },\n                activeIndex: 0,\n                realIndex: 0,\n                isBeginning: true,\n                isEnd: false,\n                translate: 0,\n                previousTranslate: 0,\n                progress: 0,\n                velocity: 0,\n                animating: false,\n                allowSlideNext: swiper.params.allowSlideNext,\n                allowSlidePrev: swiper.params.allowSlidePrev,\n                touchEvents: function touchEvents() {\n                    const touch = [ \"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\" ];\n                    const desktop = [ \"pointerdown\", \"pointermove\", \"pointerup\" ];\n                    swiper.touchEventsTouch = {\n                        start: touch[0],\n                        move: touch[1],\n                        end: touch[2],\n                        cancel: touch[3]\n                    };\n                    swiper.touchEventsDesktop = {\n                        start: desktop[0],\n                        move: desktop[1],\n                        end: desktop[2]\n                    };\n                    return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n                }(),\n                touchEventsData: {\n                    isTouched: void 0,\n                    isMoved: void 0,\n                    allowTouchCallbacks: void 0,\n                    touchStartTime: void 0,\n                    isScrolling: void 0,\n                    currentTranslate: void 0,\n                    startTranslate: void 0,\n                    allowThresholdMove: void 0,\n                    focusableElements: swiper.params.focusableElements,\n                    lastClickTime: utils_now(),\n                    clickTimeout: void 0,\n                    velocities: [],\n                    allowMomentumBounce: void 0,\n                    isTouchEvent: void 0,\n                    startMoving: void 0\n                },\n                allowClick: true,\n                allowTouchMove: swiper.params.allowTouchMove,\n                touches: {\n                    startX: 0,\n                    startY: 0,\n                    currentX: 0,\n                    currentY: 0,\n                    diff: 0\n                },\n                imagesToLoad: [],\n                imagesLoaded: 0\n            });\n            swiper.emit(\"_swiper\");\n            if (swiper.params.init) swiper.init();\n            return swiper;\n        }\n        enable() {\n            const swiper = this;\n            if (swiper.enabled) return;\n            swiper.enabled = true;\n            if (swiper.params.grabCursor) swiper.setGrabCursor();\n            swiper.emit(\"enable\");\n        }\n        disable() {\n            const swiper = this;\n            if (!swiper.enabled) return;\n            swiper.enabled = false;\n            if (swiper.params.grabCursor) swiper.unsetGrabCursor();\n            swiper.emit(\"disable\");\n        }\n        setProgress(progress, speed) {\n            const swiper = this;\n            progress = Math.min(Math.max(progress, 0), 1);\n            const min = swiper.minTranslate();\n            const max = swiper.maxTranslate();\n            const current = (max - min) * progress + min;\n            swiper.translateTo(current, \"undefined\" === typeof speed ? 0 : speed);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        emitContainerClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const cls = swiper.el.className.split(\" \").filter((className => 0 === className.indexOf(\"swiper\") || 0 === className.indexOf(swiper.params.containerModifierClass)));\n            swiper.emit(\"_containerClasses\", cls.join(\" \"));\n        }\n        getSlideClasses(slideEl) {\n            const swiper = this;\n            if (swiper.destroyed) return \"\";\n            return slideEl.className.split(\" \").filter((className => 0 === className.indexOf(\"swiper-slide\") || 0 === className.indexOf(swiper.params.slideClass))).join(\" \");\n        }\n        emitSlidesClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const updates = [];\n            swiper.slides.each((slideEl => {\n                const classNames = swiper.getSlideClasses(slideEl);\n                updates.push({\n                    slideEl,\n                    classNames\n                });\n                swiper.emit(\"_slideClass\", slideEl, classNames);\n            }));\n            swiper.emit(\"_slideClasses\", updates);\n        }\n        slidesPerViewDynamic(view, exact) {\n            if (void 0 === view) view = \"current\";\n            if (void 0 === exact) exact = false;\n            const swiper = this;\n            const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;\n            let spv = 1;\n            if (params.centeredSlides) {\n                let slideSize = slides[activeIndex].swiperSlideSize;\n                let breakLoop;\n                for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n                for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            } else if (\"current\" === view) for (let i = activeIndex + 1; i < slides.length; i += 1) {\n                const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                if (slideInView) spv += 1;\n            } else for (let i = activeIndex - 1; i >= 0; i -= 1) {\n                const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                if (slideInView) spv += 1;\n            }\n            return spv;\n        }\n        update() {\n            const swiper = this;\n            if (!swiper || swiper.destroyed) return;\n            const {snapGrid, params} = swiper;\n            if (params.breakpoints) swiper.setBreakpoint();\n            swiper.updateSize();\n            swiper.updateSlides();\n            swiper.updateProgress();\n            swiper.updateSlidesClasses();\n            function setTranslate() {\n                const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate;\n                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                swiper.setTranslate(newTranslate);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n            let translated;\n            if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n                setTranslate();\n                if (swiper.params.autoHeight) swiper.updateAutoHeight();\n            } else {\n                if ((\"auto\" === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true); else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                if (!translated) setTranslate();\n            }\n            if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n            swiper.emit(\"update\");\n        }\n        changeDirection(newDirection, needUpdate) {\n            if (void 0 === needUpdate) needUpdate = true;\n            const swiper = this;\n            const currentDirection = swiper.params.direction;\n            if (!newDirection) newDirection = \"horizontal\" === currentDirection ? \"vertical\" : \"horizontal\";\n            if (newDirection === currentDirection || \"horizontal\" !== newDirection && \"vertical\" !== newDirection) return swiper;\n            swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n            swiper.emitContainerClasses();\n            swiper.params.direction = newDirection;\n            swiper.slides.each((slideEl => {\n                if (\"vertical\" === newDirection) slideEl.style.width = \"\"; else slideEl.style.height = \"\";\n            }));\n            swiper.emit(\"changeDirection\");\n            if (needUpdate) swiper.update();\n            return swiper;\n        }\n        mount(el) {\n            const swiper = this;\n            if (swiper.mounted) return true;\n            const $el = dom(el || swiper.params.el);\n            el = $el[0];\n            if (!el) return false;\n            el.swiper = swiper;\n            const getWrapperSelector = () => `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n            const getWrapper = () => {\n                if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                    const res = dom(el.shadowRoot.querySelector(getWrapperSelector()));\n                    res.children = options => $el.children(options);\n                    return res;\n                }\n                if (!$el.children) return dom($el).children(getWrapperSelector());\n                return $el.children(getWrapperSelector());\n            };\n            let $wrapperEl = getWrapper();\n            if (0 === $wrapperEl.length && swiper.params.createElements) {\n                const document = ssr_window_esm_getDocument();\n                const wrapper = document.createElement(\"div\");\n                $wrapperEl = dom(wrapper);\n                wrapper.className = swiper.params.wrapperClass;\n                $el.append(wrapper);\n                $el.children(`.${swiper.params.slideClass}`).each((slideEl => {\n                    $wrapperEl.append(slideEl);\n                }));\n            }\n            Object.assign(swiper, {\n                $el,\n                el,\n                $wrapperEl,\n                wrapperEl: $wrapperEl[0],\n                mounted: true,\n                rtl: \"rtl\" === el.dir.toLowerCase() || \"rtl\" === $el.css(\"direction\"),\n                rtlTranslate: \"horizontal\" === swiper.params.direction && (\"rtl\" === el.dir.toLowerCase() || \"rtl\" === $el.css(\"direction\")),\n                wrongRTL: \"-webkit-box\" === $wrapperEl.css(\"display\")\n            });\n            return true;\n        }\n        init(el) {\n            const swiper = this;\n            if (swiper.initialized) return swiper;\n            const mounted = swiper.mount(el);\n            if (false === mounted) return swiper;\n            swiper.emit(\"beforeInit\");\n            if (swiper.params.breakpoints) swiper.setBreakpoint();\n            swiper.addClasses();\n            if (swiper.params.loop) swiper.loopCreate();\n            swiper.updateSize();\n            swiper.updateSlides();\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();\n            if (swiper.params.preloadImages) swiper.preloadImages();\n            if (swiper.params.loop) swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n            swiper.attachEvents();\n            swiper.initialized = true;\n            swiper.emit(\"init\");\n            swiper.emit(\"afterInit\");\n            return swiper;\n        }\n        destroy(deleteInstance, cleanStyles) {\n            if (void 0 === deleteInstance) deleteInstance = true;\n            if (void 0 === cleanStyles) cleanStyles = true;\n            const swiper = this;\n            const {params, $el, $wrapperEl, slides} = swiper;\n            if (\"undefined\" === typeof swiper.params || swiper.destroyed) return null;\n            swiper.emit(\"beforeDestroy\");\n            swiper.initialized = false;\n            swiper.detachEvents();\n            if (params.loop) swiper.loopDestroy();\n            if (cleanStyles) {\n                swiper.removeClasses();\n                $el.removeAttr(\"style\");\n                $wrapperEl.removeAttr(\"style\");\n                if (slides && slides.length) slides.removeClass([ params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass ].join(\" \")).removeAttr(\"style\").removeAttr(\"data-swiper-slide-index\");\n            }\n            swiper.emit(\"destroy\");\n            Object.keys(swiper.eventsListeners).forEach((eventName => {\n                swiper.off(eventName);\n            }));\n            if (false !== deleteInstance) {\n                swiper.$el[0].swiper = null;\n                deleteProps(swiper);\n            }\n            swiper.destroyed = true;\n            return null;\n        }\n        static extendDefaults(newDefaults) {\n            utils_extend(extendedDefaults, newDefaults);\n        }\n        static get extendedDefaults() {\n            return extendedDefaults;\n        }\n        static get defaults() {\n            return defaults;\n        }\n        static installModule(mod) {\n            if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];\n            const modules = core_Swiper.prototype.__modules__;\n            if (\"function\" === typeof mod && modules.indexOf(mod) < 0) modules.push(mod);\n        }\n        static use(module) {\n            if (Array.isArray(module)) {\n                module.forEach((m => core_Swiper.installModule(m)));\n                return core_Swiper;\n            }\n            core_Swiper.installModule(module);\n            return core_Swiper;\n        }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup => {\n        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {\n            core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        }));\n    }));\n    core_Swiper.use([ Resize, Observer ]);\n    const core = core_Swiper;\n    function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n        const document = ssr_window_esm_getDocument();\n        if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {\n            if (!params[key] && true === params.auto) {\n                let element = swiper.$el.children(`.${checkProps[key]}`)[0];\n                if (!element) {\n                    element = document.createElement(\"div\");\n                    element.className = checkProps[key];\n                    swiper.$el.append(element);\n                }\n                params[key] = element;\n                originalParams[key] = element;\n            }\n        }));\n        return params;\n    }\n    function Navigation(_ref) {\n        let {swiper, extendParams, on, emit} = _ref;\n        extendParams({\n            navigation: {\n                nextEl: null,\n                prevEl: null,\n                hideOnClick: false,\n                disabledClass: \"swiper-button-disabled\",\n                hiddenClass: \"swiper-button-hidden\",\n                lockClass: \"swiper-button-lock\"\n            }\n        });\n        swiper.navigation = {\n            nextEl: null,\n            $nextEl: null,\n            prevEl: null,\n            $prevEl: null\n        };\n        function getEl(el) {\n            let $el;\n            if (el) {\n                $el = dom(el);\n                if (swiper.params.uniqueNavElements && \"string\" === typeof el && $el.length > 1 && 1 === swiper.$el.find(el).length) $el = swiper.$el.find(el);\n            }\n            return $el;\n        }\n        function toggleEl($el, disabled) {\n            const params = swiper.params.navigation;\n            if ($el && $el.length > 0) {\n                $el[disabled ? \"addClass\" : \"removeClass\"](params.disabledClass);\n                if ($el[0] && \"BUTTON\" === $el[0].tagName) $el[0].disabled = disabled;\n                if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? \"addClass\" : \"removeClass\"](params.lockClass);\n            }\n        }\n        function update() {\n            if (swiper.params.loop) return;\n            const {$nextEl, $prevEl} = swiper.navigation;\n            toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);\n            toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);\n        }\n        function onPrevClick(e) {\n            e.preventDefault();\n            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slidePrev();\n        }\n        function onNextClick(e) {\n            e.preventDefault();\n            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slideNext();\n        }\n        function init() {\n            const params = swiper.params.navigation;\n            swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n                nextEl: \"swiper-button-next\",\n                prevEl: \"swiper-button-prev\"\n            });\n            if (!(params.nextEl || params.prevEl)) return;\n            const $nextEl = getEl(params.nextEl);\n            const $prevEl = getEl(params.prevEl);\n            if ($nextEl && $nextEl.length > 0) $nextEl.on(\"click\", onNextClick);\n            if ($prevEl && $prevEl.length > 0) $prevEl.on(\"click\", onPrevClick);\n            Object.assign(swiper.navigation, {\n                $nextEl,\n                nextEl: $nextEl && $nextEl[0],\n                $prevEl,\n                prevEl: $prevEl && $prevEl[0]\n            });\n            if (!swiper.enabled) {\n                if ($nextEl) $nextEl.addClass(params.lockClass);\n                if ($prevEl) $prevEl.addClass(params.lockClass);\n            }\n        }\n        function destroy() {\n            const {$nextEl, $prevEl} = swiper.navigation;\n            if ($nextEl && $nextEl.length) {\n                $nextEl.off(\"click\", onNextClick);\n                $nextEl.removeClass(swiper.params.navigation.disabledClass);\n            }\n            if ($prevEl && $prevEl.length) {\n                $prevEl.off(\"click\", onPrevClick);\n                $prevEl.removeClass(swiper.params.navigation.disabledClass);\n            }\n        }\n        on(\"init\", (() => {\n            init();\n            update();\n        }));\n        on(\"toEdge fromEdge lock unlock\", (() => {\n            update();\n        }));\n        on(\"destroy\", (() => {\n            destroy();\n        }));\n        on(\"enable disable\", (() => {\n            const {$nextEl, $prevEl} = swiper.navigation;\n            if ($nextEl) $nextEl[swiper.enabled ? \"removeClass\" : \"addClass\"](swiper.params.navigation.lockClass);\n            if ($prevEl) $prevEl[swiper.enabled ? \"removeClass\" : \"addClass\"](swiper.params.navigation.lockClass);\n        }));\n        on(\"click\", ((_s, e) => {\n            const {$nextEl, $prevEl} = swiper.navigation;\n            const targetEl = e.target;\n            if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {\n                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n                let isHidden;\n                if ($nextEl) isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass); else if ($prevEl) isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n                if (true === isHidden) emit(\"navigationShow\"); else emit(\"navigationHide\");\n                if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n                if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n            }\n        }));\n        Object.assign(swiper.navigation, {\n            update,\n            init,\n            destroy\n        });\n    }\n    function initSliders() {\n        if (document.querySelector(\".tmpl_hh_slider__body\")) new core(\".tmpl_hh_slider__body\", {\n            modules: [ Navigation ],\n            slidesPerView: 1,\n            speed: 800,\n            navigation: {\n                nextEl: \".tmpl_hh_slider__arrow_next\",\n                prevEl: \".tmpl_hh_slider__arrow_prev\"\n            }\n        });\n    }\n    window.addEventListener(\"load\", (function(e) {\n        initSliders();\n    }));\n    let addWindowScrollEvent = false;\n    setTimeout((() => {\n        if (addWindowScrollEvent) {\n            let windowScroll = new Event(\"windowScroll\");\n            window.addEventListener(\"scroll\", (function(e) {\n                document.dispatchEvent(windowScroll);\n            }));\n        }\n    }), 0);\n})();\n//\n</script>\n\n\t\t\t\t<div class=\"tmpl_hh_wrapper\">\n\t\t\t<div class=\"tmpl_hh_hero\">\n\t\t\t\t<div class=\"tmpl_hh_hero__body\">\n\t\t\t\t\t<div class=\"tmpl_hh_hero__logo\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/236521.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<h2 class=\"tmpl_hh_hero__title\">Задаем тренды\n\t\t\t\t\t\tв технологиях\n\t\t\t\t\t\tритейла</h2>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"tmpl_hh_hero__right\">\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235846.jpg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235843.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235847.jpg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235844.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235853.jpg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235850.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235848.jpg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235845.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_hero__item\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235849.jpg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"tmpl_hh_content\">\n\t\t\t\t <p><em><strong>X5 Group </strong>- лидер офлайн- и онлайн-рынка продуктов питания. Мы управляем портфелем брендов сетевых магазинов «Пятёрочка», «Перекрёсток», «Карусель», «Чижик», цифровыми бизнесами «Перекрёсток Впрок», «Около», 5Post, а также собственными службами логистики, прямого импорта и рядом цифровых сервисов для партнёров.</em></p> <p><em><strong>Х5 Технологии</strong> — это отдельная бизнес-единица Х5 Group, которая отвечает за создание комплексных цифровых решений для бизнес-единиц Х5.</em></p> <p><em>Наша команда — это 3000+ специалистов по информационным технологиям и большим данным. Мы разрабатываем решения, которые помогают десяткам миллионов людей.</em></p> <p><strong>«Прогнозирование спроса»</strong>: модели машинного обучения и алгоритмы, на основе данных по чекам и остаткам предупреждают сотрудников магазинов о том, что надо проверить/положить товар на полки. Продукт прошел стадию пилот (600 магазинов) и теперь дорабатывается и масштабируется на 15+ тыс. магазинов. Команда: ≈10 человек</p> <p><strong>Стек</strong>: Python 3.5-3.8., Fastapi, Hadoop, PySpark + Airflow. PostgreSQL, Kafka, Kibana, ElasticSearch. Docker, K8s, GitLab.</p> <p><strong>Основные задачи (детальнее расскажем на собеседовании)</strong>:</p> <ul> <li>Написание пайплайнов по работе с данными с использованием Airflow, Spark (пример: регулярный расчет фичей для модели, построение витрин с данными. их обновление, расчет метрик качества данных для мониторинга)</li> <li>Оптимизация расчета фичей для модели для выдерживания SLA при масштабировании продукта под большее количество магазинов</li> <li>Настройка мониторинга и алертинга качества данных и фичей с использованием Zabbix, Grafana</li> <li>Написание unit тестов (pytest), тестов для различных участков ML пайплайна, участие в код ревью</li> <li>Не обязательно, но будет большим плюсом: опыт работы с ML, выведения ML моделей в продакшн</li> </ul> <p><strong>Мы сможем рассмотреть на вакансию кандидатов, у которых есть</strong>:</p> <ul> <li>Опыт работы с Python от 2 лет</li> <li>Опыт с Hadoop, Hive, Spark</li> <li>Знание SQL (чтобы писать и оптимизировать запросы)</li> </ul> <ul> <li>Знание классических алгоритмов и структур данных</li> <li>Опыт работы с docker (kubernetes, pyspark, airflow и ds фреймворков python– не обязательно, но будет плюсом)</li> <li>Умение пользоваться git'ом и работать в команде</li> </ul> <p><strong>Мы предлагаем:</strong></p> <ul> <li>Схему мотивации: Fix + бонус (20% годового оклада)</li> <li>Удобный офис в Москве или 100% удаленная работа</li> <li>Гибкий график работы</li> <li>Обратная связь, возможность профессионального и карьерного роста (2 раза в год оценка персонала)</li> <li>Возможность обучаться и сертифицироваться за счёт компании: внешние тренинги и семинары по профессиональным тематикам, отраслевые конференции, программа развития управленческих навыков, очные мастер-классы, платформы онлайн-образования и многое другое</li> <li>Яркую корпоративную жизнь с большим количеством мероприятий, конкурсов и возможностей для творческой реализации</li> <li>Широкий пакет ДМС (включая выезд за рубеж и стоматологию), страхование жизни и здоровья</li> <li>Программу привилегий Prime-zone (скидки на товары и услуги и специальные предложения от компаний-партнёров)</li> <li>Материальную помощь сотрудникам, попавшим в сложную жизненную ситуацию</li> </ul> <p>Присоединяйся к одной из самых быстрорастущих цифровых команд России!</p> <p><strong>X</strong><strong>5</strong><strong> </strong><strong>Group</strong><strong>. Создавай новый ритейл</strong></p></div>\n\t\t\t<p class=\"tmpl_hh_company\">\n\t\t\t\tООО \"КОРПОРАТИВНЫЙ ЦЕНТР ИКС 5\" представляет бренд Х5 Тech\n\t\t\t</p>\n\t\t\t<div class=\"tmpl_hh_footer\">\n\t\t\t\t<div class=\"tmpl_hh_benefits\">\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235809.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tНашими решениями пользуются десятки тысяч людей внутри компании и миллионы\n\t\t\t\t\t\t\tклиентов вовне\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235811.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tСообщество экспертов:\n\t\t\t\t\t\t\tможно общаться и обмениваться опытом на митапах, демо-днях\n\t\t\t\t\t\t\tи конференциях\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235813.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tМы поможем развиваться: цифровая академия, лидерский клуб, школы технических специалистов\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/236218.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tХ5 — это стабильная компания.\n\t\t\t\t\t\t\tУ нас достаточно ресурсов для того, чтобы сотрудники чувствовали себя комфортно и уверенно\n\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235812.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tВ X5 много проектов\n\t\t\t\t\t\t\tи направлений, между которыми можно перемещаться\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_benefits__item\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_benefits__icon\">\n\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235810.svg\" alt=\"\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"tmpl_hh_benefits__text\">\n\t\t\t\t\t\t\tГибридный формат работы.\n\t\t\t\t\t\t\tВ Х5 можно работать\n\t\t\t\t\t\t\tв офисе, дома или совмещать\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"tmpl_hh_slider__control\">\n\t\t\t\t\t<div class=\"tmpl_hh_slider__arrow tmpl_hh_slider__arrow_prev\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235807.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"tmpl_hh_slider__arrow tmpl_hh_slider__arrow_next\">\n\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235807.svg\" alt=\"\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"tmpl_hh_slider\">\n\t\t\t\t\t<div class=\"tmpl_hh_slider__body swiper\">\n\t\t\t\t\t\t<div class=\"tmpl_hh_slider__wrapper swiper-wrapper\">\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235851.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235816.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235818.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235817.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235823.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235819.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235820.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235821.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235822.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"tmpl_hh_slider__slide swiper-slide\">\n\t\t\t\t\t\t\t\t<img src=\"https://hhcdn.ru/ichameleon/235824.jpg\" alt=\"\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n","vacancy_constructor_template":null,"key_skills":[{"name":"Python"},{"name":"Spark"},{"name":"Hadoop"}],"accept_handicapped":false,"accept_kids":false,"archived":false,"response_url":null,"specializations":[],"professional_roles":[{"id":"96","name":"Программист, разработчик"}],"code":null,"hidden":false,"quick_responses_allowed":false,"driver_license_types":[],"accept_incomplete_resumes":false,"employer":{"id":"9352463","name":"X5 Tech","url":"https://api.hh.ru/employers/9352463?host=hh.ru","alternate_url":"https://hh.ru/employer/9352463","logo_urls":null,"vacancies_url":"https://api.hh.ru/vacancies?employer_id=9352463&host=hh.ru","trusted":true},"published_at":"2023-02-27T08:30:17+0300","created_at":"2023-02-27T08:30:17+0300","initial_created_at":"2023-02-27T08:30:17+0300","negotiations_url":null,"suitable_resumes_url":null,"apply_alternate_url":"https://hh.ru/applicant/vacancy_response?vacancyId=77403977","has_test":false,"test":null,"alternate_url":"https://hh.ru/vacancy/77403977","working_days":[],"working_time_intervals":[],"working_time_modes":[],"accept_temporary":false,"languages":[]}